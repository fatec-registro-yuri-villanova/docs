### **Jetpack Compose**

Jetpack Compose é o kit de ferramentas moderno e recomendado pelo Google para construir interfaces de usuário em Android de forma **declarativa**. A beleza do Compose reside na sua filosofia de **componentização**, onde você constrói interfaces complexas a partir de blocos de construção menores e reutilizáveis. Vamos explorar como cada um desses componentes fundamentais se encaixa para criar uma tela de login funcional.

-----

### **Diferenças entre XML e Jetpack Compose**

A principal mudança trazida pelo Jetpack Compose é a transição de uma abordagem **imperativa (XML)** para uma **declarativa (Compose)**.

  * **Abordagem Imperativa (XML):**
      * **Como Funciona:** Você constrói a UI separadamente em arquivos XML. Para interagir com os elementos (como um botão ou campo de texto), você precisa "encontrá-los" no código Kotlin usando `findViewById` e, em seguida, alterar suas propriedades. O processo é manual e passo a passo.
      * **Exemplo:**
        1.  Você cria um `<Button>` no arquivo `activity_main.xml`.
        2.  No arquivo `MainActivity.kt`, você usa `val button = findViewById<Button>(R.id.my_button)`.
        3.  Para mudar o texto, você faz `button.text = "Novo Texto"`.
  * **Abordagem Declarativa (Jetpack Compose):**
      * **Como Funciona:** Você descreve como sua interface deve ser, e o Compose se encarrega de construí-la e atualizá-la automaticamente. A UI é uma função do seu estado. Não há necessidade de `findViewById` ou de manipular a UI manualmente.
      * **Exemplo:**
        1.  Você cria uma função `@Composable` que descreve o botão e o texto dele.
        2.  Você usa uma variável de estado (`var text by remember { mutableStateOf("Texto Original") }`).
        3.  Para mudar o texto, você simplesmente atualiza a variável de estado (`text = "Novo Texto"`), e o Compose redesenha o botão para você.

Essa mudança simplifica drasticamente o código e o torna mais intuitivo.

### **Componente de Texto (Text)**

O componente `Text` é o alicerce de qualquer interface baseada em texto. Ele é responsável por exibir strings na tela e oferece uma ampla gama de parâmetros para personalização, como `fontSize`, `color` e `fontWeight`. Sua simplicidade é sua maior força: ele se concentra em uma única tarefa — exibir texto de forma eficiente.

**Exemplo:**

```kotlin
import androidx.compose.material3.Text
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

@Composable
fun TituloDaTela() {
    Text(
        text = "Login",
        fontSize = 28.sp,
        color = Color.DarkGray,
        fontWeight = FontWeight.Bold
    )
}
```

### **Componente de Campo de Texto (TextField)**

O `TextField` é o componente que permite ao usuário inserir dados. Diferente de abordagens imperativas, ele não gerencia seu próprio estado. Em vez disso, ele é controlado externamente por uma variável de estado. Isso garante um **fluxo de dados unidirecional** claro: o estado flui para o `TextField` (o que é exibido) e os eventos do usuário (a digitação) fluem de volta para a lógica que irá atualizar esse estado.

  * **`value`**: O texto que o campo exibe. É sempre uma representação do estado atual.
  * **`onValueChange`**: Uma função que é chamada toda vez que o usuário altera o texto. É aqui que você atualiza a variável de estado.

**Exemplo:**

```kotlin
import androidx.compose.material3.TextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue

@Composable
fun EmailInputField() {
    var email by remember { mutableStateOf("") }
    TextField(
        value = email,
        onValueChange = { novoTexto -> email = novoTexto },
        label = { Text("E-mail") }
    )
}
```

### **Componente de Botão (Button)**

O `Button` é o componente de ação. Seu funcionamento é igualmente declarativo, com um parâmetro `onClick` que define a lógica a ser executada quando o botão é pressionado. O conteúdo dentro do botão pode ser qualquer outro componente, como um `Text` ou um ícone.

  * **`onClick`**: Uma função lambda onde você define a ação, como autenticar um usuário ou enviar um formulário.
  * **Conteúdo**: O que o botão exibe.

**Exemplo:**

```kotlin
import androidx.compose.material3.Button
import androidx.compose.material3.Text

@Composable
fun LoginButton() {
    Button(onClick = {
        // Lógica de login seria executada aqui
        println("Botão de login clicado!")
    }) {
        Text(text = "Entrar")
    }
}
```

-----

### **Componentes de Layout: `Column` e `Row`**

No Compose, a organização dos componentes é feita por meio de funções de layout. As mais fundamentais são `Column` e `Row`, que seguem a mesma lógica das `Views` nativas, mas com a simplicidade da abordagem declarativa.

  * **`Column`**: Organiza os elementos filhos em uma **disposição vertical**. Pense em uma coluna de itens, um abaixo do outro. É ideal para formulários, listas verticais ou qualquer layout que precise empilhar componentes.
  * **`Row`**: Organiza os elementos filhos em uma **disposição horizontal**. Pense em uma linha de itens, um ao lado do outro. É ideal para barras de ferramentas, navegação ou para alinhar itens como texto e ícones.

A combinação desses dois componentes é o que permite criar layouts complexos e responsivos.

**Exemplo de uso:**

```kotlin
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier

@Composable
fun ProfileLayout() {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        // Alinha os itens da coluna ao centro horizontalmente
        Text(text = "Nome de usuário") // Primeiro item
        Text(text = "Uma biografia curta") // Segundo item
        Row {
            // Um Row dentro da Column, alinhando itens horizontalmente
            Text(text = "Seguidores: 100")
            Text(text = "Seguindo: 50")
        }
    }
}
```

-----

### **Gerenciamento de Estado e Recomposição**

O gerenciamento de estado é o coração do Jetpack Compose. O **estado** é qualquer valor que pode mudar e afetar a interface. Para que o Compose saiba quando redesenhar a UI (um processo chamado **recomposição**), você precisa usar as ferramentas certas.

#### **A Dupla Imbatível: `remember` e `mutableStateOf`**

  * **`mutableStateOf`**: Cria uma variável que é "observável". Quando o valor dentro dela é alterado, o Compose é notificado e sabe que a UI precisa ser atualizada.
  * **`remember`**: Funciona como a "memória" de um componente. Ele guarda o objeto criado por `mutableStateOf` e garante que ele não seja reinicializado toda vez que a função `Composable` for redesenhada. Sem `remember`, o valor do seu contador ou campo de texto voltaria a zero a cada mudança na tela, o que inviabilizaria a interação.
  * **`by`**: É um atalho de propriedade do Kotlin que torna a sintaxe mais limpa. Em vez de escrever `minhaVariavel.value = "novo valor"`, você pode simplesmente usar `minhaVariavel = "novo valor"`.

#### **Padrão de Fluxo de Dados Unidirecional**

Esse é o princípio fundamental do gerenciamento de estado em Compose. Ele é composto por dois fluxos:

1.  **Estado para baixo**: O estado da sua aplicação (por exemplo, o texto digitado) flui do componente pai para os componentes filhos.
2.  **Eventos para cima**: As interações do usuário (como digitar em um `TextField` ou clicar em um `Button`) geram eventos que são enviados para o componente pai.

O componente pai, ao receber o evento, atualiza seu estado, que por sua vez aciona a **recomposição** dos componentes filhos, criando um ciclo de atualização contínua e eficiente.

#### **Elevação de Estado (`State Hoisting`)**

A melhor prática em Compose é manter os componentes o mais "burros" possível. Em vez de cada componente gerenciar seu próprio estado, um componente pai gerencia o estado e o "eleva" (do inglês, *hoists*). Ele passa o estado como parâmetro para os filhos e também passa as funções de callback (`onValueChange`, `onClick`) para que os filhos possam notificar o pai sobre as mudanças.

**Vantagens da Elevação de Estado:**

  * **Componentes Reutilizáveis:** Os componentes filhos não se importam com o estado, tornando-os mais genéricos.
  * **Testabilidade:** A lógica de estado fica separada da UI.
  * **Menos Bugs:** Evita que componentes diferentes manipulem o mesmo estado de forma inconsistente.

### **Componentização em Ação: A Tela de Login**

Vamos combinar tudo o que aprendemos para construir uma tela de login completa, demonstrando a **componentização** e a elevação de estado.

```kotlin
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

// Componente reutilizável de campo de entrada (sem estado próprio)
@Composable
fun LoginInputField(label: String, value: String, onValueChange: (String) -> Unit) {
    TextField(
        value = value,
        onValueChange = onValueChange,
        label = { Text(label) }
    )
}

// Componente reutilizável de botão (sem estado próprio)
@Composable
fun ActionButton(text: String, onClick: () -> Unit) {
    Button(onClick = onClick) {
        Text(text = text)
    }
}

// O componente principal que gerencia o estado da tela
@Composable
fun LoginScreen() {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }

    Column(modifier = Modifier.padding(16.dp)) {
        Text(text = "Bem-vindo!", style = MaterialTheme.typography.headlineMedium)

        Spacer(modifier = Modifier.height(16.dp))

        LoginInputField(
            label = "E-mail",
            value = email,
            onValueChange = { email = it } // O evento de digitação sobe para o pai
        )

        Spacer(modifier = Modifier.height(16.dp))

        LoginInputField(
            label = "Senha",
            value = password,
            onValueChange = { password = it } // O evento de digitação sobe para o pai
        )

        Spacer(modifier = Modifier.height(16.dp))

        ActionButton(
            text = "Entrar",
            onClick = {
                // Aqui a lógica de autenticação é executada
                println("Autenticando com e-mail: $email e senha: $password")
            }
        )
    }
}
```

-----

### **Atividades de Fixação**

Agora, vamos colocar a mão na massa para solidificar os conceitos. As atividades a seguir combinam o uso de `Text`, `TextField`, `Button`, `Column`, `Row` e **estado**.

#### **Atividade prática 1: Criando um Contador Interativo**

  * **Objetivo:** Construa um contador interativo para entender o funcionamento do estado e da recomposição.

    1.  No seu projeto, localize o arquivo `MainActivity.kt`.
    2.  Dentro da função principal `@Composable`, adicione um `Column`.
    3.  Dentro do `Column`, crie uma variável de estado para o contador usando `remember { mutableStateOf(0) }`.
    4.  Adicione um `Text` que exiba o valor atual do contador.
    5.  Adicione um `Button` abaixo do `Text`.
    6.  No `onClick` do `Button`, incremente o valor do contador.
    7.  Execute o aplicativo e veja a interface ser atualizada automaticamente a cada clique no botão.

  * **Teste de Mesa:**

      * **Entrada:** Clicar no botão 3 vezes.
      * **Saída Esperada:** O texto exibido na tela do contador deve mudar de "Valor: 0" para "Valor: 3".

#### **Atividade prática 2: Criando uma Lista de Tarefas (To-Do List)**

  * **Objetivo:** Crie uma lista de tarefas simples para entender como gerenciar o estado de uma coleção de itens.

    1.  Crie uma variável de estado para armazenar uma lista de strings, por exemplo, `var tasks by remember { mutableStateOf(listOf<String>()) }`.
    2.  Adicione um `TextField` para o usuário digitar uma nova tarefa. Use outra variável de estado para o texto do campo.
    3.  Adicione um `Button` com o texto "Adicionar". No `onClick`, adicione o texto do `TextField` à lista de tarefas e limpe o campo.
    4.  Use um `Column` para exibir a lista de tarefas, usando um loop (por exemplo, `tasks.forEach { task -> Text(text = task) }`) para exibir cada item.

  * **Teste de Mesa:**

      * **Entrada:** Digite "Comprar leite" e clique em "Adicionar". Em seguida, digite "Estudar Kotlin" e clique em "Adicionar".
      * **Saída Esperada:** A tela deve exibir os dois textos, um abaixo do outro: "Comprar leite" e "Estudar Kotlin".

#### **Atividade prática 3: Calculadora de Gasto de Combustível**

  * **Objetivo:** Crie uma tela para calcular o gasto de combustível. A UI deve ter campos para o usuário inserir o valor e o tipo de combustível, e um botão que realiza o cálculo e exibe o resultado.

    1.  Crie uma variável de estado para o valor do combustível e outra para o tipo.
    2.  Use `TextField` para cada uma das entradas.
    3.  Adicione um `Button` para disparar a função de cálculo.
    4.  Exiba o resultado do cálculo em um `Text`.

  * **Teste de Mesa:**

      * **Entrada:** Valor do combustível: 5.50 (Gasolina), 4.20 (Etanol). Digite "5.50" no campo de valor e "Gasolina" no campo de tipo.
      * **Saída Esperada:** Ao clicar no botão, a tela deve exibir o resultado do cálculo, por exemplo: "O gasto total é de R$ [valor\_calculado]".

#### **Atividade prática 4: Calculadora de Imposto de Renda**

  * **Objetivo:** Crie uma tela para calcular o Imposto de Renda (IR) de um valor de salário mensal.

      * Use um `TextField` para o usuário inserir o valor do salário.
      * Use o estado para armazenar o valor do salário.
      * Adicione um `Button` para disparar a função de cálculo.
      * Exiba o resultado em um `Text`.

  * **Tabela de alíquotas (simplificada para o exercício):**

      * **Até R$ 2.000,00:** Isento
      * **De R$ 2.000,01 a R$ 3.000,00:** 7.5%
      * **De R$ 3.000,01 a R$ 4.500,00:** 15%
      * **Acima de R$ 4.500,00:** 22.5%

  * **Teste de Mesa:**

      * **Entrada:** Digite "3500" no campo de salário.
      * **Saída Esperada:** O texto de resultado deve exibir "Imposto de Renda: R$ 525.00" (pois 3500 \* 15% = 525).