**1. Depend√™ncias no Gradle Version Catalog (`libs.versions.toml`)**

```toml
[versions]
# VERS√ïES PARA C√ÇMERA E IMAGEM
camerax = "1.3.1" # Vers√£o est√°vel do CameraX
coil = "2.7.0"   # Vers√£o est√°vel do Coil Compose

[libraries]
# DEPEND√äNCIAS DO CAMERAX
androidx-camerax-core = { group = "androidx.camera", name = "camera-core", version.ref = "camerax" }
androidx-camerax-camera2 = { group = "androidx.camera", name = "camera-camera2", version.ref = "camerax" }
androidx-camerax-lifecycle = { group = "androidx.camera", name = "camera-lifecycle", version.ref = "camerax" }
androidx-camerax-view = { group = "androidx.camera", name = "camera-view", version.ref = "camerax" }

# DEPEND√äNCIA DO COIL
coil-compose = { group = "io.coil-kt", name = "coil-compose", version.ref = "coil" }
```

**Instru√ß√£o:** Aplique estas novas depend√™ncias no `app/build.gradle.kts` e sincronize seu projeto.

**2. Permiss√µes no Manifesto (`AndroidManifest.xml`)**

**Conceito:** O Android precisa saber que voc√™ vai acessar um hardware sens√≠vel (a c√¢mera).

```xml
<uses-permission android:name="android.permission.CAMERA" />
<uses-feature android:name="android.hardware.camera.any" /> 
```

-----

### Conceitos e Utilit√°rios (`object Class`)

**3. Entendendo a `object Class` (Singleton)**

| Conceito | Explica√ß√£o |
| :--- | :--- |
| **O que faz?** | Garante que a classe ter√° apenas uma inst√¢ncia em todo o tempo de vida da aplica√ß√£o. |
| **Uso Ideal** | Perfeita para fun√ß√µes utilit√°rias, constantes e gerentes que n√£o precisam de estado pr√≥prio e podem ser acessadas globalmente (como o objeto `Math`). |
| **Acesso** | Voc√™ acessa os m√©todos e propriedades diretamente pelo nome do objeto, sem precisar criar uma inst√¢ncia (`Objeto.funcao()`). |

**4. Utilit√°rio de Permiss√£o (`utils/PermissionUtils.kt`)**

**Fun√ß√£o:** Checar o estado da permiss√£o da c√¢mera.

```kotlin
package com.fatec.camerajetpack.utils

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat

/**
 * UTILITY OBJECT: Singleton para verificar o estado da permiss√£o da C√¢mera.
 */
object PermissionUtils {
    
    val CAMERA_PERMISSION = Manifest.permission.CAMERA

    /**
     * @param context: O contexto da Activity/Aplica√ß√£o.
     * @return true se a permiss√£o foi concedida.
     */
    fun isCameraPermissionGranted(context: Context): Boolean {
        return ContextCompat.checkSelfPermission(
            context,
            CAMERA_PERMISSION
        ) == PackageManager.PERMISSION_GRANTED
    }
}
```

**5. Utilit√°rio de Imagem (`utils/ImageUtils.kt`)**

**Fun√ß√£o:** Mover a foto do cache tempor√°rio para a Galeria.

```kotlin
package com.fatec.camerajetpack.utils

import android.content.ContentValues
import android.content.Context
import android.net.Uri
import android.os.Build
import android.provider.MediaStore
import java.io.File
import android.util.Log // Adicionado para debug

/**
 * UTILITY OBJECT: Singleton respons√°vel por salvar o arquivo de imagem no MediaStore (Galeria).
 */
object ImageUtils {
    
    fun saveImageToGallery(context: Context, imageUri: Uri) {
        val file = File(imageUri.path ?: return)
        
        // 1. Define os metadados da imagem
        val contentValues = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, file.name)
            put(MediaStore.MediaColumns.MIME_TYPE, "image/jpeg")
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                // Organiza a imagem em uma pasta espec√≠fica na Galeria
                put(MediaStore.MediaColumns.RELATIVE_PATH, "DCIM/CameraJetpack")
            }
        }

        val resolver = context.contentResolver
        var uri: Uri? = null
        
        try {
            // 2. Insere o registro e obt√©m a URI final do local permanente
            uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
            
            if (uri != null) {
                // 3. Copia os dados do arquivo tempor√°rio para o destino permanente
                resolver.openOutputStream(uri).use { outputStream ->
                    file.inputStream().use { inputStream ->
                        inputStream.copyTo(outputStream!!)
                    }
                }
                
                // 4. Limpeza: Deleta o arquivo tempor√°rio do cache.
                file.delete()
            }
        } catch (e: Exception) {
            Log.e("ImageUtils", "Falha ao salvar imagem na galeria: ${e.message}")
            // Em caso de falha, tenta reverter a cria√ß√£o do registro
            uri?.let { resolver.delete(it, null, null) }
        }
    }
}
```

-----

### O Viewfinder (Preview) e a Captura

**6. L√≥gica de Captura (`ui/camera/CameraView.kt` - Classe Auxiliar)**

Esta classe isola a complexidade de iniciar a captura de foto do CameraX, criando um arquivo tempor√°rio no cache.

```kotlin
package com.fatec.camerajetpack.ui.camera

import android.content.Context
import android.util.Log
import android.widget.Toast
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCapture.OutputFileOptions
import androidx.camera.core.ImageCaptureException
import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.ExecutorService

/**
 * CLASSE DE CONTROLE: Cont√©m a fun√ß√£o takePhoto() que ser√° chamada pelo bot√£o do Compose.
 */
class CameraView(
    private val imageCapture: ImageCapture?,
    private val executor: ExecutorService // O executor de threads para o salvamento
) {
    fun takePhoto(context: Context, onImageCaptured: (File) -> Unit) {
        val imageCaptureInstance = imageCapture ?: return // Se n√£o estiver pronto, sai
        
        // 1. Define o nome do arquivo com timestamp e o local (cache)
        val photoFile = File(
            context.cacheDir, 
            SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS", Locale.US).format(System.currentTimeMillis()) + ".jpg"
        )
        
        val outputOptions = OutputFileOptions.Builder(photoFile).build()
        
        // 2. Executa a captura
        imageCaptureInstance.takePicture(
            outputOptions,
            executor,
            object : ImageCapture.OnImageSavedCallback {
                override fun onError(exc: ImageCaptureException) {
                    Log.e("CameraX", "Falha na captura: ${exc.message}", exc)
                    Toast.makeText(context, "Erro na captura", Toast.LENGTH_SHORT).show()
                }

                override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                    // 3. Em caso de sucesso, chama o callback com o arquivo tempor√°rio
                    onImageCaptured(photoFile)
                }
            }
        )
    }
}
```

**7. Composable do Preview (`ui/camera/CameraView.kt` - Composable)**

O `AndroidView` √© nossa "ponte", ele hospeda a `PreviewView` nativa. Em Jetpack Compose, as fun√ß√µes @Composable devem ser puras e r√°pidas. O bloco LaunchedEffect √© o lugar seguro para executar c√≥digo que n√£o √© puramente composicional (chamado de Efeito Colateral), como: opera√ß√µes de rede, manipula√ß√£o de ciclo de vida, ou, como no nosso caso, inicializa√ß√£o de bibliotecas ass√≠ncronas como o CameraX., garantindo que a refer√™ncia de captura esteja pronta antes de ser usada pelo bot√£o.

```kotlin
package com.fatec.camerajetpack.ui.camera

import android.util.Log
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.runtime.* import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.lifecycle.LifecycleOwner
import java.util.concurrent.ExecutorService

/**
 * COMPOSABLE DO PREVIEW: Hospeda a View nativa PreviewView do CameraX.
 */
@Composable
fun CameraView(
    modifier: Modifier = Modifier,
    lifecycleOwner: LifecycleOwner,
    executor: ExecutorService,
    cameraViewRef: MutableState<CameraView?> // Refer√™ncia de retorno
) {
    val context = LocalContext.current
    
    // 1. Cria a View nativa PreviewView
    val previewView: PreviewView = remember { 
        PreviewView(context).apply {
            this.scaleType = PreviewView.ScaleType.FILL_CENTER
        } 
    }
    
    val imageCapture: MutableState<ImageCapture?> = remember { mutableStateOf(null) }

    // üí° CORRE√á√ÉO/MELHORIA: Usamos LaunchedEffect para gerenciar a liga√ß√£o ass√≠ncrona do CameraX.
    LaunchedEffect(lifecycleOwner) {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(context)

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()
            
            // Configura√ß√£o do Preview
            val preview = Preview.Builder().build().also { 
                it.setSurfaceProvider(previewView.surfaceProvider) 
            }

            // Configura√ß√£o da Captura de Imagem
            val capture = ImageCapture.Builder().build()
            imageCapture.value = capture // Atribui o valor de captura

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                // Desvincula tudo antes de vincular para garantir um estado limpo
                cameraProvider.unbindAll()
                // Vincula os casos de uso (Preview e Captura) ao ciclo de vida
                cameraProvider.bindToLifecycle(
                    lifecycleOwner, cameraSelector, preview, capture
                )
                
                cameraViewRef.value = CameraView(imageCapture.value, executor)
                Log.d("CameraX", "Casos de uso vinculados e CameraView ref atualizada com sucesso.")
                
            } catch (exc: Exception) {
                Log.e("CameraX", "Falha ao vincular casos de uso", exc)
            }

        }, ContextCompat.getMainExecutor(context))
    }

    // 2. O AndroidView apenas hospeda o PreviewView que foi configurado acima.
    AndroidView(
        modifier = modifier,
        factory = { previewView }
    )
}
```

**8. Tela de Pr√©-visualiza√ß√£o (`ui/camera/ImagePreviewScreen.kt`)**

**Fun√ß√£o:** Exibir a foto capturada e receber a a√ß√£o do usu√°rio (salvar ou descartar).

```kotlin
package com.fatec.camerajetpack.ui.camera

import android.net.Uri
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage // Usa Coil para carregar a URI

/**
 * TELA DE DECIS√ÉO: Exibe a foto capturada e gerencia as a√ß√µes do usu√°rio.
 */
@Composable
fun ImagePreviewScreen(
    uri: Uri,
    onSave: (Uri) -> Unit,
    onDiscard: () -> Unit // Notifica a MainScreen para voltar ao modo C√¢mera
) {
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.SpaceBetween
    ) {
        // Exibe a imagem usando a URI tempor√°ria
        AsyncImage(
            model = uri,
            contentDescription = "Pr√©-visualiza√ß√£o da foto",
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f),
            contentScale = ContentScale.Crop
        )

        // Controles de A√ß√£o
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            Button(
                onClick = onDiscard,
                modifier = Modifier
                    .weight(1f)
                    .padding(end = 8.dp)
            ) { Text("Descartar") }

            Button(
                onClick = { onSave(uri) },
                modifier = Modifier
                    .weight(1f)
                    .padding(start = 8.dp)
            ) { Text("Salvar") }
        }
    }
}
```

-----

### Orquestra√ß√£o e Fluxo

**9. Tela Principal (`ui/screens/MainScreen.kt`)**

O Gerenciador de Estado da aplica√ß√£o. Ele lida com permiss√µes, cria o thread executor e usa o estado `capturedImageUri` para alternar entre as telas `CameraMode` e `PreviewMode`.

```kotlin
package com.fatec.camerajetpack.ui.screens

import android.content.Context
import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.unit.dp
import androidx.core.net.toUri
import androidx.lifecycle.LifecycleOwner
import com.fatec.camerajetpack.ui.camera.CameraView
import com.fatec.camerajetpack.ui.camera.ImagePreviewScreen
import com.fatec.camerajetpack.utils.PermissionUtils
import com.fatec.camerajetpack.utils.ImageUtils
import java.io.File
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

@Composable
fun MainScreen() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    
    // 1. ESTADO CHAVE: Controla qual tela estamos vendo.
    var capturedImageUri by remember { mutableStateOf<Uri?>(null) }
    
    // Executor de thread para as opera√ß√µes de I/O do CameraX
    val cameraExecutor: ExecutorService = remember { Executors.newSingleThreadExecutor() }

    // 2. Gerenciamento de Permiss√µes
    var hasCameraPermission by remember { mutableStateOf(PermissionUtils.isCameraPermissionGranted(context)) }

    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { isGranted -> hasCameraPermission = isGranted }
    )

    // Solicita a permiss√£o na primeira vez que o Composable √© composto
    LaunchedEffect(Unit) {
        if (!hasCameraPermission) {
            permissionLauncher.launch(PermissionUtils.CAMERA_PERMISSION)
        }
    }

    Scaffold(modifier = Modifier.fillMaxSize()) { paddingValues ->
        Box(modifier = Modifier
            .padding(paddingValues)
            .fillMaxSize()) {
            if (hasCameraPermission) {
                // 3. L√ìGICA DE FLUXO
                if (capturedImageUri == null) {
                    // MODO C√ÇMERA
                    CameraMode(
                        context = context, 
                        lifecycleOwner = lifecycleOwner, 
                        cameraExecutor = cameraExecutor,
                        onImageCaptured = { file -> capturedImageUri = file.toUri() } // Muda para o Preview
                    )
                } else {
                    // MODO PREVIEW
                    PreviewMode(
                        uri = capturedImageUri!!,
                        onSave = { uri ->
                            ImageUtils.saveImageToGallery(context, uri)
                            Toast.makeText(context, "Imagem salva na galeria!", Toast.LENGTH_LONG).show()
                            capturedImageUri = null // Volta para C√¢mera
                        },
                        onDiscard = {
                            capturedImageUri = null // Volta para C√¢mera
                        }
                    )
                }
            } else {
                Text("Aguardando Permiss√£o da C√¢mera...", modifier = Modifier.align(Alignment.Center))
            }
        }
    }
    
    // Limpeza: Garante que o Executor de thread seja desligado
    DisposableEffect(Unit) {
        onDispose { cameraExecutor.shutdown() }
    }
}

// ----------------------------------
// Composables Auxiliares (Wrappers)
// ----------------------------------

@Composable
fun CameraMode(
    context: Context, lifecycleOwner: LifecycleOwner, cameraExecutor: ExecutorService,
    onImageCaptured: (File) -> Unit
) {
    // Refer√™ncia para podermos chamar a fun√ß√£o takePhoto() de dentro do Button
    val cameraViewRef = remember { mutableStateOf<CameraView?>(null) }
    
    Box(modifier = Modifier.fillMaxSize()) {
        CameraView(
            modifier = Modifier.fillMaxSize(),
            lifecycleOwner = lifecycleOwner,
            executor = cameraExecutor,
            cameraViewRef = cameraViewRef
        )
        
        Button(
            onClick = { cameraViewRef.value?.takePhoto(context, onImageCaptured) },
            // O bot√£o s√≥ aparece e s√≥ funciona se a refer√™ncia CameraView n√£o for nula (ou seja, a c√¢mera est√° pronta)
            enabled = cameraViewRef.value != null, 
            modifier = Modifier.align(Alignment.BottomCenter).padding(32.dp)
        ) {
            Text("Tirar Foto")
        }
    }
}

@Composable
fun PreviewMode(uri: Uri, onSave: (Uri) -> Unit, onDiscard: () -> Unit) {
    ImagePreviewScreen(uri = uri, onSave = onSave, onDiscard = onDiscard)
}
```

**10. Activity Host (`MainActivity.kt`)**

A Activity √© o ponto de entrada que inicializa a interface do Compose.

```kotlin
package com.fatec.camerajetpack

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Scaffold
import androidx.compose.ui.Modifier
import com.fatec.camerajetpack.ui.screens.MainScreen
import com.fatec.camerajetpack.ui.theme.CameraJetpackTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            CameraJetpackTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) {  innerPadding ->
                    MainScreen(
                        modifier = Modifier.padding(innerPadding)
                    )
                }
            }
        }
    }
}
```
