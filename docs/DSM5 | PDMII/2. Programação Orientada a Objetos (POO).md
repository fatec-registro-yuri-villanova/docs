### **Programação Orientada a Objetos (POO)**

POO é um paradigma de programação que organiza o código em torno de objetos.

### **Classes e Objetos**

Uma **classe** é um modelo, enquanto um **objeto** é uma instância dessa classe.

```kotlin
// Classe
class Pessoa(val nome: String, var idade: Int)

// Objeto (instância da classe)
val pessoa = Pessoa("João", 30)
```

### **Herança e Polimorfismo**

  * **Herança:** É um princípio que permite que uma classe (chamada **subclasse** ou **classe filha**) herde atributos e métodos de outra classe (chamada **superclasse** ou **classe pai**). Isso promove a reutilização de código e a organização de classes em uma hierarquia. Em Kotlin, a herança é `final` por padrão, então você deve usar a palavra-chave `open` para permitir que uma classe ou um método seja herdado.

    ```kotlin
    // Superclasse / Classe pai
    open class Animal(val nome: String) {
        open fun emitirSom() {
            println("O animal faz um som.")
        }
    }

    // Subclasse / Classe filha
    class Cachorro(nome: String) : Animal(nome) {
        override fun emitirSom() {
            println("$nome faz au-au!")
        }
    }
    ```

  * **Polimorfismo:** Significa "muitas formas". Refere-se à capacidade de um objeto assumir várias formas. Em Kotlin, o polimorfismo ocorre quando uma **subclasse** sobrescreve um método de sua **superclasse**, permitindo que o mesmo método se comporte de maneira diferente dependendo do objeto que o chama. Isso permite que você trate objetos de diferentes classes de forma uniforme.

    ```kotlin
    fun main() {
        val meuAnimal: Animal = Cachorro("Rex")
        meuAnimal.emitirSom() // Saída: Rex faz au-au!
    }
    ```

### **Classes Avançadas e Enumerações**

Kotlin oferece tipos de classes especiais que facilitam tarefas comuns e tornam o código mais seguro.

  * **`data class`**: São classes projetadas para apenas guardar dados. O compilador do Kotlin gera automaticamente métodos úteis como `equals()`, `hashCode()`, `toString()`, `copy()`, e `componentN()` baseados nas propriedades declaradas no construtor primário. Isso elimina a necessidade de escrever código repetitivo.

    ```kotlin
    data class Usuario(val nome: String, val idade: Int)

    fun main() {
        val usuario1 = Usuario("Ana", 25)
        println(usuario1) // Saída: Usuario(nome=Ana, idade=25)
        val usuario2 = usuario1.copy(idade = 26)
    }
    ```

  * **`sealed class`**: São classes que representam hierarquias de classes restritas. Todos os subtipos de uma `sealed class` devem ser declarados dentro do mesmo arquivo, garantindo que o compilador saiba todos os possíveis subtipos. Isso é extremamente útil em expressões `when`, onde o compilador pode garantir que todas as possibilidades foram tratadas.

    ```kotlin
    sealed class Resultado
    data class Sucesso(val dados: String) : Resultado()
    data class Erro(val codigo: Int) : Resultado()

    fun processarResultado(resultado: Resultado) {
        when (resultado) {
            is Sucesso -> println("Dados recebidos: ${resultado.dados}")
            is Erro -> println("Erro, código: ${resultado.codigo}")
        }
    }
    ```

  * **`enum class`**: Enumeradores são usados para representar um conjunto de constantes fixas. Em Kotlin, as classes `enum` são mais poderosas do que em outras linguagens, podendo ter suas próprias propriedades e métodos.

    ```kotlin
    enum class DiaSemana(val sigla: String) {
        SEGUNDA("Seg"),
        TERCA("Ter"),
        QUARTA("Qua"),
        QUINTA("Qui"),
        SEXTA("Sex"),
        SABADO("Sab"),
        DOMINGO("Dom")
    }

    fun main() {
        val hoje = DiaSemana.SEXTA
        println("Hoje é ${hoje.sigla}") // Saída: Hoje é Sex
    }
    ```

**Atividade prática 1: Desafio da Calculadora**

  * **Objetivo:** Crie uma calculadora usando os princípios de POO.

    1.  Crie uma classe `Calculadora` com duas propriedades, `valor1` e `valor2`, para armazenar os números de entrada.
    2.  Crie quatro métodos: `somar()`, `subtrair()`, `multiplicar()` e `dividir()`. Cada função deve realizar a operação e retornar o resultado.
    3.  Crie um objeto da classe e utilize os métodos para realizar as operações.

  * **Teste de Mesa:**

      * **Entrada:** Instancie a classe `Calculadora` com os valores 10 e 5.
      * **Saída Esperada:**
          * `soma: 15`
          * `subtração: 5`
          * `multiplicação: 50`
          * `divisão: 2`

**Atividade prática 2: Herança e Polimorfismo**

  * **Objetivo:** Crie uma classe base chamada `Animal` com a propriedade `nome` e o método `emitirSom()`. Em seguida, crie duas classes filhas, `Cachorro` e `Gato`, que herdem de `Animal` e sobrescrevam o método `emitirSom()` para imprimir o som específico de cada animal.

  * **Teste de Mesa:**

      * **Entrada:**
        1.  Crie um objeto da classe `Cachorro` com o nome "Rex".
        2.  Crie um objeto da classe `Gato` com o nome "Félix".
        3.  Chame o método `emitirSom()` em ambos os objetos.
      * **Saída Esperada:**
          * `Rex faz au-au!`
          * `Félix faz miau!`

**Atividade prática 3: Modelando um Produto**

  * **Objetivo:** Crie uma classe `Produto` com as propriedades `nome` e `preco`. Em seguida, adicione um método chamado `aplicarDesconto` que recebe uma porcentagem de desconto e retorna o preço final do produto após o desconto.

  * **Teste de Mesa:**

      * **Entrada:** Instancie a classe `Produto` com `nome = "Televisor"` e `preco = 2000.00`. Chame o método `aplicarDesconto` com o valor `10.0` (10%).
      * **Saída Esperada:** `1800.0`

