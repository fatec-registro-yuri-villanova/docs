{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Setup","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>pip install mkdocs</code> - To install MkDocs.</li> <li><code>pip install mkdocs-material</code> - To install mkdocs-material.</li> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n     ...       # Other markdown pages, images and other files.\n              ...       # Other markdown pages, images and other files.\n                                ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"LDM/introdu%C3%A7%C3%A3o/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"LDM/introdu%C3%A7%C3%A3o/#o-universo-do-desenvolvimento-cross-platform","title":"** O Universo do Desenvolvimento Cross-Platform**","text":"<p>O desenvolvimento de software vive em constante evolu\u00e7\u00e3o, impulsionado pela diversidade de dispositivos e sistemas operacionais. Nesse cen\u00e1rio, o desenvolvimento multiplataforma (ou cross-platform) surge como uma abordagem estrat\u00e9gica para criar solu\u00e7\u00f5es que funcionam em m\u00faltiplos ambientes, como iOS, Android e web, a partir de uma \u00fanica base de c\u00f3digo.</p>"},{"location":"LDM/introdu%C3%A7%C3%A3o/#definicao-e-conceito","title":"Defini\u00e7\u00e3o e Conceito","text":"<p>O conceito de desenvolvimento multiplataforma se baseia na cria\u00e7\u00e3o de um software que pode ser executado em diferentes plataformas sem a necessidade de ser reescrito para cada uma delas. Isso significa que, em vez de desenvolver um aplicativo separado para iOS e outro para Android, por exemplo, o desenvolvedor escreve o c\u00f3digo uma \u00fanica vez, e ele \u00e9 adaptado para funcionar em ambos os sistemas.</p> <p>Essa abordagem oferece uma resposta direta aos desafios impostos pela fragmenta\u00e7\u00e3o do mercado de tecnologia, permitindo que empresas e desenvolvedores alcancem um p\u00fablico mais amplo de forma mais eficiente.</p>"},{"location":"LDM/introdu%C3%A7%C3%A3o/#por-que-usar-vantagens-e-desvantagens","title":"Por que Usar? Vantagens e Desvantagens","text":"<p>A decis\u00e3o de adotar o desenvolvimento multiplataforma envolve a pondera\u00e7\u00e3o de seus pontos fortes e fracos.</p> <p>Vantagens:</p> <ul> <li>Reutiliza\u00e7\u00e3o de C\u00f3digo: A capacidade de compartilhar a mesma base de c\u00f3digo entre diferentes plataformas \u00e9 a principal vantagem. Isso otimiza o tempo de trabalho e reduz drasticamente o esfor\u00e7o de desenvolvimento.</li> <li>Redu\u00e7\u00e3o de Custos e Tempo: Com um \u00fanico projeto e uma \u00fanica equipe, os custos e o tempo de desenvolvimento e manuten\u00e7\u00e3o s\u00e3o consideravelmente menores. O tempo de lan\u00e7amento no mercado (time-to-market) tamb\u00e9m \u00e9 acelerado.</li> <li>Manuten\u00e7\u00e3o Centralizada: A manuten\u00e7\u00e3o do software \u00e9 simplificada. As atualiza\u00e7\u00f5es e corre\u00e7\u00f5es de bugs s\u00e3o aplicadas em um \u00fanico local e propagadas para todas as vers\u00f5es do aplicativo.</li> <li>Alcance de Mercado: Com o aplicativo dispon\u00edvel em diferentes lojas de aplicativos e sistemas operacionais, a visibilidade e o alcance da sua solu\u00e7\u00e3o s\u00e3o ampliados, permitindo que mais usu\u00e1rios tenham acesso a ela.</li> </ul> <p>Desvantagens:</p> <ul> <li>Limita\u00e7\u00f5es de Recursos Nativos: Pode haver restri\u00e7\u00f5es no acesso a certas funcionalidades espec\u00edficas de um sistema operacional, como sensores avan\u00e7ados ou componentes de interface de usu\u00e1rio (UI) exclusivos.</li> <li>Desempenho: Em alguns casos, especialmente em aplicativos que exigem processamento intenso, o desempenho pode ser inferior ao de um aplicativo nativo. No entanto, ferramentas modernas como Flutter e React Native t\u00eam minimizado essa diferen\u00e7a.</li> <li>Experi\u00eancia do Usu\u00e1rio (UX): Embora a consist\u00eancia seja um ponto positivo, pode ser dif\u00edcil replicar a experi\u00eancia \"nativa\" exata que os usu\u00e1rios de cada plataforma est\u00e3o acostumados a ter.</li> </ul>"},{"location":"LDM/introdu%C3%A7%C3%A3o/#cross-platform-vs-nativo-o-dilema-da-escolha","title":"Cross-Platform vs. Nativo: O Dilema da Escolha","text":"<p>A escolha entre o desenvolvimento multiplataforma e o nativo n\u00e3o \u00e9 sobre qual \u00e9 melhor, mas sobre qual \u00e9 o mais adequado para o seu projeto.</p> <ul> <li>Desenvolvimento Nativo: O aplicativo \u00e9 constru\u00eddo com as linguagens e ferramentas espec\u00edficas de cada plataforma (por exemplo, Swift para iOS ou Java/Kotlin para Android). Isso garante o melhor desempenho, acesso total aos recursos do dispositivo e uma experi\u00eancia de usu\u00e1rio perfeitamente integrada. \u00c9 a escolha ideal para jogos, aplicativos com gr\u00e1ficos complexos ou que dependem de funcionalidades muito espec\u00edficas do sistema.</li> <li>Desenvolvimento Multiplataforma: A abordagem cross-platform prioriza a velocidade e o custo. \u00c9 perfeita para projetos com prazos apertados, or\u00e7amentos limitados e que buscam ter uma presen\u00e7a ampla no mercado sem um grande investimento inicial.</li> </ul>"},{"location":"LDM/introdu%C3%A7%C3%A3o/#ferramentas-e-frameworks-populares","title":"Ferramentas e Frameworks Populares","text":"<p>A popularidade do desenvolvimento multiplataforma se deve em grande parte \u00e0s poderosas ferramentas dispon\u00edveis. As mais not\u00e1veis s\u00e3o:</p> <ul> <li>Flutter: Desenvolvido pelo Google, utiliza a linguagem de programa\u00e7\u00e3o Dart. O Flutter \u00e9 conhecido por seu alto desempenho e por permitir a cria\u00e7\u00e3o de interfaces de usu\u00e1rio ricas e visualmente atraentes com facilidade.</li> <li>React Native: Criado pelo Facebook, utiliza a linguagem JavaScript e o framework React. Sua popularidade se d\u00e1, em grande parte, por permitir que desenvolvedores web aproveitem seus conhecimentos em JavaScript para criar aplicativos m\u00f3veis.</li> <li>Kotlin Multiplatform (KMP): Desenvolvido pela JetBrains, utiliza a linguagem Kotlin. Diferente de outras ferramentas, o foco principal do KMP \u00e9 compartilhar a l\u00f3gica de neg\u00f3cio (como regras de neg\u00f3cio, acesso a dados e camada de rede) entre as plataformas, enquanto a interface do usu\u00e1rio (UI) \u00e9 desenvolvida de forma nativa para cada sistema. Essa abordagem combina a efici\u00eancia do c\u00f3digo compartilhado com a experi\u00eancia de usu\u00e1rio nativa.</li> </ul> <p>Outras ferramentas como Xamarin, Ionic e PhoneGap tamb\u00e9m s\u00e3o mencionadas como op\u00e7\u00f5es v\u00e1lidas, cada uma com suas particularidades.</p> <p>Em resumo, a escolha do caminho a seguir deve ser feita ap\u00f3s uma an\u00e1lise cuidadosa dos objetivos e requisitos do projeto, priorizando a abordagem que melhor se alinha com as necessidades e limita\u00e7\u00f5es do seu contexto.</p>"},{"location":"PDMI/Hooks/Hooks/","title":"Hooks","text":""},{"location":"PDMI/Hooks/Hooks/#entendendo-a-revolucao-dos-componentes-funcionais","title":"Entendendo a Revolu\u00e7\u00e3o dos Componentes Funcionais \ud83c\udfa3","text":""},{"location":"PDMI/Hooks/Hooks/#o-que-sao-hooks","title":"O que s\u00e3o Hooks?","text":"<p>Hooks s\u00e3o fun\u00e7\u00f5es especiais introduzidas no React 16.8 (2019) que permitem usar estado, lifecycle methods e outros recursos do React sem classes. Eles \"conectam\" (hook into) a funcionalidade do React diretamente em componentes funcionais, simplificando a escrita e a organiza\u00e7\u00e3o do c\u00f3digo.  </p>"},{"location":"PDMI/Hooks/Hooks/#principais-hooks","title":"Principais Hooks","text":"<p>\ud83d\udd39 <code>useState</code>: Gerencia estados em componentes funcionais. \ud83d\udd39 <code>useEffect</code>: Executa efeitos colaterais (como chamadas API) ap\u00f3s renderiza\u00e7\u00e3o. \ud83d\udd39 <code>useContext</code>: Acessa o contexto global da aplica\u00e7\u00e3o. \ud83d\udd39 <code>useReducer</code>: Gerencia estados complexos com l\u00f3gica centralizada. \ud83d\udd39 <code>useRef</code>: Referencia elementos do DOM ou armazena valores mut\u00e1veis. \ud83d\udd39 Hooks Customizados: Fun\u00e7\u00f5es reutiliz\u00e1veis criadas por voc\u00ea (ex: <code>useFetch</code>).  </p>"},{"location":"PDMI/Hooks/Hooks/#por-que-os-hooks-foram-criados","title":"Por que os Hooks Foram Criados?","text":"<ol> <li>Problemas com Classes: </li> <li>Complexidade em reutilizar l\u00f3gica entre componentes.  </li> <li>Dificuldade em entender <code>this</code> e m\u00e9todos de lifecycle.  </li> <li>Objetivo dos Hooks: </li> <li>Simplificar componentes com fun\u00e7\u00f5es puras.  </li> <li>Facilitar o compartilhamento de l\u00f3gica entre componentes.  </li> </ol>"},{"location":"PDMI/Hooks/Hooks/#regras-dos-hooks","title":"Regras dos Hooks \ud83d\udea8","text":"<ol> <li>S\u00f3 use Hooks no Top-Level: </li> <li>N\u00e3o chame Hooks dentro de loops, condi\u00e7\u00f5es ou fun\u00e7\u00f5es aninhadas.  </li> <li>S\u00f3 use em Componentes Funcionais ou Custom Hooks: </li> <li>N\u00e3o funcionam em classes.  </li> </ol>"},{"location":"PDMI/Hooks/Hooks/#beneficios-dos-hooks","title":"Benef\u00edcios dos Hooks \u2728","text":"<p>\u2705 C\u00f3digo mais limpo: Menos boilerplate comparado a classes. \u2705 Reutiliza\u00e7\u00e3o de l\u00f3gica: Custom Hooks permitem compartilhar funcionalidades. \u2705 Organiza\u00e7\u00e3o: Separa\u00e7\u00e3o clara de preocupa\u00e7\u00f5es (ex: estado, efeitos). \u2705 Ado\u00e7\u00e3o gradual: Podem ser usados ao lado de componentes em classe.  </p>"},{"location":"PDMI/Hooks/Hooks/#exemplo-usestate-useeffect","title":"Exemplo: <code>useState</code> + <code>useEffect</code>","text":"<pre><code>    import { useState, useEffect } from 'react';  \n\n    function Timer() {  \n    const [seconds, setSeconds] = useState(0);  \n\n    useEffect(() =&gt; {  \n        const interval = setInterval(() =&gt; {  \n        setSeconds(prev =&gt; prev + 1);  \n        }, 1000);  \n\n        return () =&gt; clearInterval(interval); // Limpeza do efeito  \n    }, []); // Executa apenas uma vez (mount)  \n\n    return &lt;p&gt;Tempo: {seconds} segundos&lt;/p&gt;;  \n    }  \n</code></pre>"},{"location":"PDMI/Hooks/Hooks/#quando-usar-hooks","title":"Quando Usar Hooks?","text":"<p>\ud83d\udd39Componentes funcionais que precisam de estado ou efeitos. \ud83d\udd39Substituir componentes em classe para simplificar o c\u00f3digo. \ud83d\udd39Compartilhar l\u00f3gica entre m\u00faltiplos componentes (via Custom Hooks).</p>"},{"location":"PDMI/Hooks/useEffect/","title":"<code>useEffect</code>","text":"<p>O useEffect \u00e9 um dos Hooks mais importantes do React e React Native. Vamos explic\u00e1-lo de forma simples e pr\u00e1tica com exemplos do seu projeto de conselhos.</p>"},{"location":"PDMI/Hooks/useEffect/#o-que-e-o-useeffect","title":"O que \u00e9 o useEffect?","text":"<p>\u00c9 um hook que permite executar efeitos colaterais em componentes funcionais. Pense nele como um substituto moderno para os m\u00e9todos de ciclo de vida (lifecycle) que existiam em componentes de classe.</p>"},{"location":"PDMI/Hooks/useEffect/#analogia-simples","title":"Analogia Simples","text":"<p>Imagine que seu componente \u00e9 uma cozinha:</p> <ul> <li>Os ingredientes (props e estado) s\u00e3o suas ferramentas</li> <li>O useEffect \u00e9 como um ajudante que faz tarefas extras quando:<ul> <li>Voc\u00ea entra na cozinha (montagem do componente)</li> <li>Voc\u00ea troca de ingredientes (atualiza\u00e7\u00e3o de depend\u00eancias)</li> <li>Voc\u00ea sai da cozinha (desmontagem do componente) </li> </ul> </li> </ul>"},{"location":"PDMI/Hooks/useEffect/#como-funciona-no-seu-codigo","title":"Como Funciona no Seu C\u00f3digo?","text":"<p>No seu componente AdviceCard, voc\u00ea usou:</p> <pre><code>useEffect(() =&gt; {\n   fetchAdvice(); \n}, []);\n</code></pre> <p>Partes do useEffect:</p> <ol> <li> <p>Fun\u00e7\u00e3o de efeito: O c\u00f3digo que ser\u00e1 executado    <pre><code>() =&gt; {\n   fetchAdvice();\n} \n</code></pre></p> </li> <li> <p>Array de depend\u00eancias: <code>[]</code> (vazio no exemplo)</p> <ul> <li>Controla quando o efeito deve ser executado novamente</li> </ul> </li> </ol>"},{"location":"PDMI/Hooks/useEffect/#os-3-comportamentos-principais","title":"Os 3 Comportamentos Principais","text":"<ol> <li> <p>Executar apenas na montagem (como no seu c\u00f3digo)    <pre><code>useEffect(() =&gt; {\n// C\u00f3digo executado uma vez quando o componente \u00e9 montado\n}, []); // Array vazio\n</code></pre></p> <ul> <li>No exemplo: Busca o primeiro conselho quando a tela \u00e9 aberta</li> </ul> </li> <li> <p>Executar quando vari\u00e1veis mudam    <pre><code>useEffect(() =&gt; {\n// C\u00f3digo executado sempre que 'algumaVariavel' mudar\n}, [algumaVariavel]);\n</code></pre></p> </li> <li> <p>Executar limpeza ao desmontar    <pre><code>useEffect(() =&gt; {\nconst timer = setInterval(() =&gt; {\n   // C\u00f3digo repetido\n}, 1000);\n\nreturn () =&gt; {\n   clearInterval(timer); // Limpeza quando o componente desmontar\n};\n}, []);\n</code></pre></p> <ul> <li>Aplicabilidade: Se voc\u00ea tivesse um timer para buscar conselhos automaticamente</li> </ul> </li> </ol>"},{"location":"PDMI/Hooks/useEffect/#exemplo-pratico","title":"Exemplo Pr\u00e1tico","text":""},{"location":"PDMI/Hooks/useEffect/#api","title":"Api","text":"<p>Documenta\u00e7\u00e3o</p>"},{"location":"PDMI/Hooks/useEffect/#1-estrutura-de-tipos-typesadvicets","title":"1. Estrutura de Tipos (types/advice.ts)","text":"<pre><code>export interface Slip {\n   id: number;\n   advice: string;\n}\n\nexport interface AdviceResponse {\n   slip: Slip;\n}\n</code></pre>"},{"location":"PDMI/Hooks/useEffect/#2-servico-de-api-servicesapits","title":"2. Servi\u00e7o de API (services/api.ts)","text":"<pre><code>import { AdviceResponse } from '../types/advice';\n\nexport const getRandomAdvice = async (): Promise&lt;AdviceResponse&gt; =&gt; {\ntry {\n   // Adicione um timestamp para evitar cache\n   const response = await fetch(`https://api.adviceslip.com/advice?t=${Date.now()}`);\n\n   if (!response.ok) {\n      throw new Error('Erro ao buscar conselho');\n   }\n\n   return await response.json();\n} catch (error) {\n   console.error('Erro na chamada da API:', error);\n   throw error;\n}\n};\n</code></pre>"},{"location":"PDMI/Hooks/useEffect/#3-componente-advicecard-componentsadvicecardtsx","title":"3. Componente AdviceCard (components/AdviceCard.tsx)","text":"<pre><code>import { getRandomAdvice } from '@/services/api';\nimport { Slip } from '@/types/advice';\nimport React, { useState, useEffect } from 'react';\nimport { \n   View, \n   Text, \n   StyleSheet, \n   TouchableOpacity, \n   ActivityIndicator \n} from 'react-native';\n\nconst AdviceCard = () =&gt; {\nconst [advice, setAdvice] = useState&lt;Slip | null&gt;(null);\nconst [loading, setLoading] = useState&lt;boolean&gt;(false);\nconst [error, setError] = useState&lt;string | null&gt;(null);\n\nconst fetchAdvice = async () =&gt; {\n   try {\n      setLoading(true);\n      setError(null);\n      const response = await getRandomAdvice();\n      setAdvice(response.slip);\n\n   } catch (err) {\n      setError('Falha ao carregar conselho. Tente novamente.');\n      console.error(err);\n   } finally {\n      setLoading(false);\n   }\n};\n\nuseEffect(() =&gt; {\n   fetchAdvice();\n}, []);\n\nif (loading &amp;&amp; !advice) {\n   return &lt;ActivityIndicator size=\"large\" /&gt;;\n}\n\nreturn (\n   &lt;View style={styles.container}&gt;\n      {error ? (\n      &lt;&gt;\n         &lt;Text style={styles.errorText}&gt;{error}&lt;/Text&gt;\n         &lt;TouchableOpacity onPress={fetchAdvice} style={styles.button}&gt;\n            &lt;Text style={styles.buttonText}&gt;Tentar novamente&lt;/Text&gt;\n         &lt;/TouchableOpacity&gt;\n      &lt;/&gt;\n      ) : (\n      &lt;&gt;\n         &lt;Text style={styles.title}&gt;Conselho #{advice?.id}&lt;/Text&gt;\n         &lt;Text style={styles.adviceText}&gt;\"{advice?.advice}\"&lt;/Text&gt;\n\n         &lt;TouchableOpacity onPress={fetchAdvice} style={styles.button}&gt;\n            &lt;Text style={styles.buttonText}&gt;Obter novo conselho&lt;/Text&gt;\n         &lt;/TouchableOpacity&gt;\n      &lt;/&gt;\n      )}\n   &lt;/View&gt;\n);\n};\n\nconst styles = StyleSheet.create({\ncontainer: {\n   padding: 20,\n   backgroundColor: '#f8f9fa',\n   borderRadius: 10,\n   margin: 20,\n   alignItems: 'center',\n},\ntitle: {\n   fontSize: 18,\n   fontWeight: 'bold',\n   marginBottom: 10,\n},\nadviceText: {\n   fontSize: 16,\n   fontStyle: 'italic',\n   textAlign: 'center',\n   marginBottom: 20,\n},\nbutton: {\n   backgroundColor: '#007bff',\n   padding: 10,\n   borderRadius: 5,\n   marginTop: 10,\n},\nbuttonText: {\n   color: 'white',\n},\nerrorText: {\n   color: 'red',\n   marginBottom: 10,\n},\n});\n\nexport default AdviceCard;\n</code></pre>"},{"location":"PDMI/Hooks/useState/","title":"<code>useState</code>","text":""},{"location":"PDMI/Hooks/useState/#gerenciamento-de-estado-com-usestate-no-react-native","title":"Gerenciamento de Estado com <code>useState</code> no React Native","text":""},{"location":"PDMI/Hooks/useState/#o-que-e-o-usestate","title":"O que \u00e9 o <code>useState</code>?","text":"<ul> <li>Hook do React para adicionar estado a componentes funcionais.  </li> <li>Retorna um valor (estado atual) e uma fun\u00e7\u00e3o para atualiz\u00e1-lo.  </li> <li>Ideal para estados locais e simples (ex: formul\u00e1rios, contadores, visibilidade de UI).  </li> </ul>"},{"location":"PDMI/Hooks/useState/#vantagens","title":"Vantagens","text":"<p>\u2705 Simplicidade: Facilita a cria\u00e7\u00e3o e atualiza\u00e7\u00e3o de estados sem classes. \u2705 Integra\u00e7\u00e3o: Funciona perfeitamente com outros Hooks (ex: <code>useEffect</code>). \u2705 Performance: Atualiza\u00e7\u00f5es eficientes com re-renderiza\u00e7\u00f5es otimizadas.  </p>"},{"location":"PDMI/Hooks/useState/#como-usar","title":"Como usar?","text":"<ol> <li> <p>Importe o Hook: <pre><code>import { useState } from 'react';  \n</code></pre></p> </li> <li> <p>Inicialize o estado: <pre><code>const [count, setCount] = useState(0); // Valor inicial: 0  \n</code></pre></p> </li> <li> <p>Atualize o estado: <pre><code>setCount(count + 1); // Atualiza para 1  \n</code></pre></p> </li> </ol>"},{"location":"PDMI/Hooks/useState/#exemplo-pratico","title":"Exemplo Pr\u00e1tico","text":"<pre><code> import { View, Text, Button } from 'react-native';  \n\n const Counter = () =&gt; {  \n const [count, setCount] = useState(0);  \n\n return (  \n     &lt;View&gt;  \n     &lt;Text&gt;Contador: {count}&lt;/Text&gt;  \n     &lt;Button  \n         title=\"Incrementar\"  \n         onPress={() =&gt; setCount(count + 1)}  \n     /&gt;  \n     &lt;/View&gt;  \n );  \n };  \n</code></pre>"},{"location":"PDMI/Hooks/useState/#dicas-importantes","title":"Dicas Importantes","text":"<ul> <li>Use para estados locais (escopo do componente).</li> <li>Evite objetos complexos; prefira m\u00faltiplos useState.</li> <li>Para estados globais, combine com Context API ou bibliotecas (ex: Redux). </li> </ul>"},{"location":"PDMI/Hooks/useState/#quando-utilizar","title":"Quando utilizar?","text":"<ul> <li>Controle de inputs, modais, dados tempor\u00e1rios.</li> <li>Componentes funcionais que precisam de estado simples.</li> <li>Evite para l\u00f3gicas complexas ou compartilhamento entre muitos componentes.</li> </ul>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/","title":"<code>Navega\u00e7\u00e3o</code>","text":""},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#navegacao-no-react-native","title":"Navega\u00e7\u00e3o no React Native","text":"<ul> <li>Reposit\u00f3rio</li> </ul>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#1-configuracao-inicial","title":"1. Configura\u00e7\u00e3o Inicial","text":"<p>1.1. Criar novo projeto    <pre><code>npx create-expo-app NavegacaoApp --template expo-template-blank-typescript\ncd NavegacaoApp\n</code></pre></p> <p>1.2. Instalar depend\u00eancias    <pre><code>npm install @react-navigation/native @react-navigation/native-stack\n</code></pre></p>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#2-estrutura-do-projeto","title":"2. Estrutura do Projeto","text":"<pre><code>/src\n   /screens\n      Home.tsx\n      Profile.tsx\n      Settings.tsx\n   /types\n      navigationTypes.ts\n   /components\n      CustomButton.tsx\nApp.tsx\n</code></pre>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#3-configurando-tipos","title":"3. Configurando Tipos","text":"<p><code>types/navigationTypes.ts</code> <pre><code>export type RootStackParamList = {\n   Home: undefined;\n   Profile: { name: string };\n   Settings: undefined;\n};\n\ndeclare global {\n   namespace ReactNavigation {\n      interface RootParamList extends RootStackParamList {}\n   }\n}\n</code></pre></p>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#4-criando-componentes-de-tela","title":"4. Criando Componentes de Tela","text":""},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#screenshometsx","title":"<code>screens/Home.tsx</code>","text":"<pre><code>import React from 'react';\nimport { View, Text, TextInput } from 'react-native';\nimport { NativeStackScreenProps } from '@react-navigation/native-stack';\nimport { RootStackParamList } from '../types/navigationTypes';\nimport { CustomButton } from '../components/CustomButton';\n\ntype Props = NativeStackScreenProps&lt;RootStackParamList, 'Home'&gt;;\n\nexport function HomeScreen({ navigation }: Props) {\nconst [name, setName] = React.useState('');\n\nreturn (\n   &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;\n      &lt;Text&gt;Home Screen&lt;/Text&gt;\n      &lt;TextInput\n      placeholder=\"Digite seu nome\"\n      value={name}\n      onChangeText={setName}\n      style={{ borderWidth: 1, padding: 10, margin: 10, width: 200 }}\n      /&gt;\n      &lt;CustomButton\n      title=\"Ir para Perfil\"\n      onPress={() =&gt; navigation.navigate('Profile', { name })}\n      /&gt;\n      &lt;CustomButton\n      title=\"Abrir Configura\u00e7\u00f5es\"\n      onPress={() =&gt; navigation.navigate('Settings')}\n      /&gt;\n   &lt;/View&gt;\n);\n}\n</code></pre>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#5-configurando-o-navegador","title":"5. Configurando o Navegador","text":""},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#apptsx","title":"<code>App.tsx</code>","text":"<pre><code>import { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { HomeScreen } from './src/screens/Home';\nimport { RootStackParamList } from './src/types/navigationTypes';\nimport { ProfileScreen } from './src/screens/Profile';\nimport { SettingsScreen } from './src/screens/Settings';\n\nconst Stack = createNativeStackNavigator&lt;RootStackParamList&gt;();\n\nexport default function App() {\nreturn (\n   &lt;NavigationContainer&gt;\n      &lt;Stack.Navigator initialRouteName=\"Home\"&gt;\n      &lt;Stack.Screen\n         name=\"Home\"\n         component={HomeScreen}\n         options={{ title: 'P\u00e1gina Inicial' }}\n      /&gt;\n      &lt;Stack.Screen\n         name=\"Profile\"\n         component={ProfileScreen}\n         options={({ route }) =&gt; ({ title: \"Perfil\"})}\n         /*  options={({ route }) =&gt; ({ title: route.params.name })} */\n      /&gt;\n      &lt;Stack.Screen\n         name=\"Settings\"\n         component={SettingsScreen}\n         options={{\n            headerStyle: {\n            backgroundColor: '#f4511e',\n            },\n            headerTintColor: '#fff',\n         }}\n      /&gt;\n      &lt;/Stack.Navigator&gt;\n   &lt;/NavigationContainer&gt;\n);\n}\n</code></pre>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#6-metodos-de-navegacao","title":"6. M\u00e9todos de Navega\u00e7\u00e3o","text":"<p>6.1. Navega\u00e7\u00e3o B\u00e1sica    <pre><code>// Navegar para nova tela\nnavigation.navigate('Profile', { name: 'Ana' });\n\n// Voltar\nnavigation.goBack();\n\n// Substituir tela atual\nnavigation.replace('Settings');\n\n// Voltar para primeira tela na pilha\nnavigation.popToTop();\n</code></pre></p> <p>6.2. Navega\u00e7\u00e3o com Push    <pre><code>// Adiciona nova tela \u00e0 pilha (mesma tela pode ser aberta m\u00faltiplas vezes)\nnavigation.push('Profile', { name: 'Segunda Tela' });\n</code></pre></p>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#7-passando-parametros","title":"7. Passando Par\u00e2metros","text":"<p>7.1. Enviando par\u00e2metros    <pre><code>// Navegar para nova tela\nnavigation.navigate('Profile', { name: 'Ana' });\n\n// Voltar\nnavigation.goBack();\n\n// Substituir tela atual\nnavigation.replace('Settings');\n\n// Voltar para primeira tela na pilha\nnavigation.popToTop();\n</code></pre></p> <p>7.2. Recebendo par\u00e2metros</p>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#profiletsx","title":"<code>Profile.tsx</code>","text":"<pre><code>import { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { RootStackParamList } from \"../types/navigationTypes\";\nimport { Text, View } from \"react-native\";\n\ntype ProfileProps = NativeStackScreenProps&lt;RootStackParamList, 'Profile'&gt;;\n\nexport function ProfileScreen({ route }: ProfileProps) {\nreturn (\n   &lt;View&gt;\n      &lt;Text&gt;Nome: {route.params.name}&lt;/Text&gt;\n   &lt;/View&gt;\n);\n}\n</code></pre>"},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#8-componente-de-botao-customizado","title":"8. Componente de Bot\u00e3o Customizado","text":""},{"location":"PDMI/Navega%C3%A7%C3%A3o/Navega%C3%A7%C3%A3o/#componentscustombuttontsx","title":"<code>components/CustomButton.tsx</code>","text":"<pre><code>import { TouchableOpacity, Text, StyleSheet } from 'react-native';\n\ntype Props = {\ntitle: string;\nonPress: () =&gt; void;\n};\n\nexport function CustomButton({ title, onPress }: Props) {\nreturn (\n   &lt;TouchableOpacity style={styles.button} onPress={onPress}&gt;\n      &lt;Text style={styles.text}&gt;{title}&lt;/Text&gt;\n   &lt;/TouchableOpacity&gt;\n);\n}\n\nconst styles = StyleSheet.create({\nbutton: {\n   backgroundColor: '#007AFF',\n   padding: 15,\n   borderRadius: 10,\n   margin: 10,\n   minWidth: 200,\n   alignItems: 'center',\n},\ntext: {\n   color: 'white',\n   fontSize: 16,\n},\n});\n</code></pre>"},{"location":"PDMI/Revis%C3%A3o/Gerenciamento%20de%20Estado/","title":"Gerenciamento de Estado","text":""},{"location":"PDMI/Revis%C3%A3o/Gerenciamento%20de%20Estado/#state-hosting-estado-elevado","title":"State Hosting (Estado Elevado)","text":"<p>O estado fica no componente pai e \u00e9 passado para os filhos via props.</p> <pre><code>// Estado no componente pai\nfunction TelaCarrinho() {\n  const [itens, setItens] = useState([]);\n  const [total, setTotal] = useState(0);\n\n  const adicionarItem = (item) =&gt; {\n    setItens([...itens, item]);\n    setTotal(total + item.preco);\n  };\n\n  return (\n    &lt;View&gt;\n      &lt;ListaItens itens={itens} /&gt;\n      &lt;BotaoAdicionar onAdicionar={adicionarItem} /&gt;\n      &lt;Total valor={total} /&gt;\n    &lt;/View&gt;\n  );\n}\n\nfunction ListaItens({ itens }) {\n  return (\n    &lt;View&gt;\n      {itens.map(item =&gt; &lt;Text key={item.id}&gt;{item.nome}&lt;/Text&gt;)}\n    &lt;/View&gt;\n  );\n}\n\nfunction BotaoAdicionar({ onAdicionar }) {\n  return (\n    &lt;Button \n      title=\"Adicionar Item\" \n      onPress={() =&gt; onAdicionar({ id: 1, nome: 'Produto', preco: 10 })}\n    /&gt;\n  );\n}\n\nfunction Total({ valor }) {\n  return &lt;Text&gt;Total: R$ {valor}&lt;/Text&gt;;\n}\n</code></pre> <p>Quando usar: Quando m\u00faltiplos componentes irm\u00e3os precisam compartilhar o mesmo estado.</p>"},{"location":"PDMI/Revis%C3%A3o/Gerenciamento%20de%20Estado/#persistent-state-estado-isolado","title":"Persistent State (Estado Isolado)","text":"<p>O estado fica isolado dentro do pr\u00f3prio componente.</p> <pre><code>// Estado isolado em cada componente\nfunction Contador({ titulo }) {\n  const [count, setCount] = useState(0); // Estado pr\u00f3prio\n\n  return (\n    &lt;View&gt;\n      &lt;Text&gt;{titulo}&lt;/Text&gt;\n      &lt;Text&gt;{count}&lt;/Text&gt;\n      &lt;Button title=\"+\" onPress={() =&gt; setCount(count + 1)} /&gt;\n      &lt;Button title=\"-\" onPress={() =&gt; setCount(count - 1)} /&gt;\n    &lt;/View&gt;\n  );\n}\n\nfunction InputBusca({ onBuscar }) {\n  const [termo, setTermo] = useState(''); // Estado pr\u00f3prio\n  const [loading, setLoading] = useState(false);\n\n  const buscar = () =&gt; {\n    setLoading(true);\n    onBuscar(termo);\n    setTimeout(() =&gt; setLoading(false), 1000);\n  };\n\n  return (\n    &lt;View&gt;\n      &lt;TextInput \n        value={termo}\n        onChangeText={setTermo}\n        placeholder=\"Buscar...\"\n      /&gt;\n      &lt;Button \n        title={loading ? \"Buscando...\" : \"Buscar\"}\n        onPress={buscar}\n        disabled={loading}\n      /&gt;\n    &lt;/View&gt;\n  );\n}\n\n// Uso dos componentes isolados\nfunction TelaExemplo() {\n  return (\n    &lt;View&gt;\n      &lt;Contador titulo=\"Contador A\" /&gt;\n      &lt;Contador titulo=\"Contador B\" /&gt;\n      &lt;InputBusca onBuscar={(termo) =&gt; console.log(termo)} /&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre> <p>Quando usar: Quando o componente \u00e9 independente e reutiliz\u00e1vel, sem necessidade de compartilhar estado.</p>"},{"location":"PDMI/Revis%C3%A3o/Gerenciamento%20de%20Estado/#resumo","title":"Resumo","text":"<ul> <li>State Hosting: Estado no pai \u2192 compartilhado entre filhos</li> <li>Persistent State: Estado no pr\u00f3prio componente \u2192 isolado e independente</li> </ul>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/","title":"Revis\u00e3o Pr\u00e1tica: PDMII e LDDM","text":""},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#repo","title":"Repo","text":"<pre><code>https://github.com/fatec-registro-yuri-villanova/bovino\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#estrutura-do-projeto","title":"Estrutura do Projeto","text":"<p>Imagine a seguinte estrutura de arquivos Kotlin em um projeto Android Studio:</p> <pre><code>app/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main/\n\u2502       \u2514\u2500\u2500 java/\n\u2502           \u2514\u2500\u2500 com/\n\u2502               \u2514\u2500\u2500 example/\n\u2502                   \u2514\u2500\u2500 bovinehealthmanager/\n\u2502                       \u251c\u2500\u2500 MainActivity.kt\n\u2502                       \u251c\u2500\u2500 ui/\n\u2502                       \u2502   \u251c\u2500\u2500 theme/\n\u2502                       \u2502   \u2502   \u251c\u2500\u2500 Theme.kt\n\u2502                       \u2502   \u2502   \u2514\u2500\u2500 Color.kt\n\u2502                       \u2502   \u251c\u2500\u2500 screens/\n\u2502                       \u2502   \u2502   \u251c\u2500\u2500 BovineListScreen.kt\n\u2502                       \u2502   \u2502   \u2514\u2500\u2500 BovineDetailScreen.kt\n\u2502                       \u2502   \u2514\u2500\u2500 components/\n\u2502                       \u2502       \u2514\u2500\u2500 BovineCard.kt\n\u2502                       \u2514\u2500\u2500 data/\n\u2502                           \u2514\u2500\u2500 Bovine.kt\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#conceitos-aplicados","title":"Conceitos Aplicados","text":""},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#1-mainactivitykt-ponto-de-entrada-e-navegacao","title":"1. MainActivity.kt - Ponto de Entrada e Navega\u00e7\u00e3o","text":"<p>Este arquivo conteria a Activity principal e configuraria o NavController e o NavHost para gerenciar a navega\u00e7\u00e3o entre as telas.</p> <pre><code>// MainActivity.kt\npackage com.fatec.bovino\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Surface\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\nimport com.fatec.bovino.ui.screens.BovineDetailScreen\nimport com.fatec.bovino.ui.screens.BovineListScreen\nimport com.fatec.bovino.ui.theme.BovinoTheme\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            BovinoTheme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    BovineAppNavigation() // Componente de navega\u00e7\u00e3o\n                }\n\n            }\n        }\n    }\n}\n\n@Composable\nfun BovineAppNavigation() {\n    val navController = rememberNavController() // O NavController lembra o estado da navega\u00e7\u00e3o\n\n    NavHost(navController = navController, startDestination = \"bovine_list\") {\n        // Define a rota para a tela de listagem de bovinos\n        composable(\"bovine_list\") {\n            BovineListScreen(\n                onNavigateToDetail = { bovineId -&gt;\n                    navController.navigate(\"bovine_detail/$bovineId\") // Navega para detalhes\n                }\n            )\n        }\n        // Define a rota para a tela de detalhes do bovino, com um argumento\n        composable(\"bovine_detail/{bovineId}\") { backStackEntry -&gt;\n            val bovineId = backStackEntry.arguments?.getString(\"bovineId\")\n            BovineDetailScreen(bovineId = bovineId) // Passa o ID para a tela de detalhes\n        }\n    }\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#2-bovinekt-modelo-de-dados","title":"2. Bovine.kt - Modelo de Dados","text":"<p>Define a estrutura de dados para um bovino.</p> <pre><code>// data/Bovine.kt\npackage com.fatec.bovino.data\n\ndata class Bovine(\n    val id: String,\n    var name: String,\n    var breed: String,\n    var healthStatus: HealthStatus,\n    var lastVaccinationDate: String\n)\n\nenum class HealthStatus {\n    SAUDAVEL, // SAUD\u00c1VEL\n    RISCO, // EM RISCO\n    VACINACAO_PENDENTE // VACINA\u00c7\u00c3O PENDENTE\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#3-bovinelistscreenkt-tela-de-listagem-de-bovinos","title":"3. BovineListScreen.kt - Tela de Listagem de Bovinos","text":"<p>Esta tela demonstra o gerenciamento de estado (lista de bovinos), Column para organiza\u00e7\u00e3o vertical, Row e Text dentro do BovineCard, e Modifier.</p> <pre><code>// ui/screens/BovineListScreen.kt\npackage com.fatec.bovino.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.* // Importa remember e mutableStateOf\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport com.fatec.bovino.data.Bovine\nimport com.fatec.bovino.data.HealthStatus\nimport com.fatec.bovino.ui.components.BovineCard\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun BovineListScreen(onNavigateToDetail: (String) -&gt; Unit) {\n    // Gerenciamento de estado para a lista de bovinos\n    // Usando 'remember' para manter a lista entre recomposi\u00e7\u00f5es\n    // Usando 'mutableStateOf' para tornar a lista observ\u00e1vel\n    // O 'by' permite acesso direto ao valor da lista sem .value\n    var bovines by remember {\n        mutableStateOf(\n            listOf(\n                Bovine(\"001\", \"Mimosa\", \"Jersey\", HealthStatus.SAUDAVEL, \"2024-05-01\"),\n                Bovine(\"002\", \"Estrela\", \"Holandesa\", HealthStatus.VACINACAO_PENDENTE, \"2023-11-15\"),\n                Bovine(\"003\", \"Fofinha\", \"Nelore\", HealthStatus.RISCO, \"2024-03-20\"),\n                Bovine(\"004\", \"Pintada\", \"Angus\", HealthStatus.SAUDAVEL, \"2024-04-10\")\n            )\n        )\n    }\n\n    // Estado para determinar se h\u00e1 algum alerta geral (para Top App Bar)\n    val hasAlert by remember {\n        derivedStateOf {\n            bovines.any { it.healthStatus == HealthStatus.RISCO || it.healthStatus == HealthStatus.VACINACAO_PENDENTE }\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Gerenciador de Bovinos\") },\n                // A cor da Top App Bar muda dinamicamente com base no estado 'hasAlert'\n                colors = TopAppBarDefaults.topAppBarColors(\n                    containerColor = if (hasAlert) Color(0xFFEF5350) else MaterialTheme.colorScheme.primary // Vermelho para alerta\n                )\n            )\n        }\n    ) { paddingValues -&gt;\n        // LazyColumn \u00e9 eficiente para listas longas, renderizando apenas os itens vis\u00edveis\n        LazyColumn(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues) // Aplica o padding da Scaffold\n                .padding(horizontal = 16.dp, vertical = 8.dp) // Modificador para padding externo\n        ) {\n            items(bovines) { bovine -&gt;\n                // BovineCard \u00e9 um Composable reutiliz\u00e1vel\n                BovineCard(bovine = bovine, onClick = { onNavigateToDetail(bovine.id) })\n                Spacer(modifier = Modifier.height(8.dp)) // Espa\u00e7amento entre os cards\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#4-bovinecardkt-componente-reutilizavel-state-hoisting","title":"4. BovineCard.kt - Componente Reutiliz\u00e1vel (State Hoisting)","text":"<p>Este componente demonstra Column, Row, Text, Modifier e o conceito de State Hoisting, onde o estado (o objeto Bovine) \u00e9 passado de cima para baixo.</p> <pre><code>// ui/components/BovineCard.kt\npackage com.fatec.bovino.ui.components\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport com.fatec.bovino.data.Bovine\nimport com.fatec.bovino.data.HealthStatus\n\n@Composable\nfun BovineCard(bovine: Bovine, onClick: () -&gt; Unit) {\n    // Determina a cor de fundo do card com base no status de sa\u00fade\n    val cardBackgroundColor = when (bovine.healthStatus) {\n        HealthStatus.SAUDAVEL -&gt; Color(0xFFE8F5E9) // Verde claro\n        HealthStatus.RISCO -&gt; Color(0xFFFFCC80) // Laranja claro\n        HealthStatus.VACINACAO_PENDENTE -&gt; Color(0xFFFFCDD2) // Vermelho claro\n    }\n\n    Card(\n        modifier = Modifier\n            .fillMaxWidth()\n            .clickable(onClick = onClick), // Torna o card clic\u00e1vel\n        shape = RoundedCornerShape(8.dp), // Cantos arredondados\n        colors = CardDefaults.cardColors(containerColor = cardBackgroundColor), // Cor de fundo do card\n        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp) // Sombra\n    ) {\n        // Column para organizar as informa\u00e7\u00f5es verticalmente\n        Column(\n            modifier = Modifier.padding(16.dp) // Padding interno\n        ) {\n            // Row para alinhar ID e Status horizontalmente\n            Row(\n                modifier = Modifier.fillMaxWidth(),\n                horizontalArrangement = Arrangement.SpaceBetween, // Espa\u00e7amento entre os elementos\n                verticalAlignment = Alignment.CenterVertically\n            ) {\n                Text(\n                    text = \"ID: ${bovine.id}\",\n                    style = MaterialTheme.typography.titleMedium // Estilo de texto do Material Theme\n                )\n                // Box para \"encaixotar\" o status com um fundo colorido\n                Box(\n                    modifier = Modifier\n                        .background(\n                            color = when (bovine.healthStatus) {\n                                HealthStatus.SAUDAVEL -&gt; Color.Green.copy(alpha = 0.7f)\n                                HealthStatus.RISCO -&gt; Color.Yellow .copy(alpha = 0.7f)\n                                HealthStatus.VACINACAO_PENDENTE -&gt; Color.Red.copy(alpha = 0.7f)\n                            },\n                            shape = RoundedCornerShape(4.dp) // Cantos arredondados para o Box\n                        )\n                        .padding(horizontal = 6.dp, vertical = 2.dp) // Padding interno do Box\n                ) {\n                    Text(\n                        text = bovine.healthStatus.name.replace(\"_\", \" \"),\n                        color = Color.White,\n                        style = MaterialTheme.typography.labelSmall\n                    )\n                }\n            }\n            Spacer(modifier = Modifier.height(4.dp)) // Espa\u00e7amento vertical\n            Text(\n                text = \"Nome: ${bovine.name}\",\n                style = MaterialTheme.typography.bodyMedium\n            )\n            Text(\n                text = \"Ra\u00e7a: ${bovine.breed}\",\n                style = MaterialTheme.typography.bodySmall\n            )\n            Text(\n                text = \"\u00daltima Vacina\u00e7\u00e3o: ${bovine.lastVaccinationDate}\",\n                style = MaterialTheme.typography.bodySmall\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#5-bovinedetailscreenkt-tela-de-detalhes-do-bovino","title":"5. BovineDetailScreen.kt - Tela de Detalhes do Bovino","text":"<p>Esta tela demonstra como receber argumentos de navega\u00e7\u00e3o e pode incluir mais gerenciamento de estado local.</p> <pre><code>// ui/screens/BovineDetailScreen.kt\npackage com.fatec.bovino.ui.screens\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport com.fatec.bovino.data.Bovine\nimport com.fatec.bovino.data.HealthStatus\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun BovineDetailScreen(bovineId: String?) {\n    // Simula a busca do bovino por ID (em um app real, viria de um ViewModel/reposit\u00f3rio)\n    val bovine = remember(bovineId) { // remember o objeto Bovine baseado no ID\n        // Exemplo de dados mockados\n        when (bovineId) {\n            \"001\" -&gt; Bovine(\"001\", \"Mimosa\", \"Jersey\", HealthStatus.SAUDAVEL, \"2024-05-01\")\n            \"002\" -&gt; Bovine(\"002\", \"Estrela\", \"Holandesa\", HealthStatus.VACINACAO_PENDENTE, \"2023-11-15\")\n            \"003\" -&gt; Bovine(\"003\", \"Fofinha\", \"Nelore\", HealthStatus.RISCO, \"2024-03-20\")\n            \"004\" -&gt; Bovine(\"004\", \"Pintada\", \"Angus\", HealthStatus.SAUDAVEL, \"2024-04-10\")\n            else -&gt; null\n        }\n    }\n\n    // Estado local para o status de sa\u00fade, permitindo altera\u00e7\u00e3o na tela de detalhes\n    // Demonstra o uso de 'by' e 'remember' para estado mut\u00e1vel\n    var currentHealthStatus by remember { mutableStateOf(bovine?.healthStatus ?: HealthStatus.SAUDAVEL) }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(title = { Text(\"Detalhes do Bovino: $bovineId\") })\n        }\n    ) { paddingValues -&gt;\n        if (bovine != null) {\n            Column(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .padding(paddingValues)\n                    .padding(16.dp),\n                horizontalAlignment = Alignment.CenterHorizontally,\n                verticalArrangement = Arrangement.Center\n            ) {\n                Text(text = \"ID: ${bovine.id}\", style = MaterialTheme.typography.headlineMedium)\n                Spacer(modifier = Modifier.height(8.dp))\n                Text(text = \"Nome: ${bovine.name}\", style = MaterialTheme.typography.titleLarge)\n                Text(text = \"Ra\u00e7a: ${bovine.breed}\", style = MaterialTheme.typography.titleMedium)\n                Text(text = \"\u00daltima Vacina\u00e7\u00e3o: ${bovine.lastVaccinationDate}\", style = MaterialTheme.typography.bodyLarge)\n                Spacer(modifier = Modifier.height(16.dp))\n\n                // Exibe o status atual com base no estado local\n                Text(text = \"Status de Sa\u00fade: ${currentHealthStatus.name.replace(\"_\", \" \")}\",\n                    style = MaterialTheme.typography.titleMedium,\n                    color = when (currentHealthStatus) {\n                        HealthStatus.SAUDAVEL -&gt; Color.Green\n                        HealthStatus.RISCO -&gt; Color.Yellow\n                        HealthStatus.VACINACAO_PENDENTE -&gt; Color.Red\n                    }\n                )\n                Spacer(modifier = Modifier.height(16.dp))\n\n                // Bot\u00f5es para mudar o status (demonstra\u00e7\u00e3o de gerenciamento de estado)\n                Row(\n                    horizontalArrangement = Arrangement.spacedBy(8.dp)\n                ) {\n                    Button(onClick = { currentHealthStatus = HealthStatus.SAUDAVEL }) {\n                        Text(\"Saud\u00e1vel\")\n                    }\n                    Button(onClick = { currentHealthStatus = HealthStatus.RISCO }) {\n                        Text(\"Em Risco\")\n                    }\n                    Button(onClick = { currentHealthStatus = HealthStatus.VACINACAO_PENDENTE }) {\n                        Text(\"Vacinar\")\n                    }\n                }\n            }\n        } else {\n            Box(\n                modifier = Modifier.fillMaxSize(),\n                contentAlignment = Alignment.Center\n            ) {\n                Text(\"Bovino n\u00e3o encontrado.\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o%20Pr%C3%A1tica/#6-themekt-e-colorkt-tematizacao-do-material-design","title":"6. Theme.kt e Color.kt - Tematiza\u00e7\u00e3o do Material Design","text":"<p>Estes arquivos definiriam as cores e a tipografia para o MaterialTheme da aplica\u00e7\u00e3o.</p> <pre><code>// ui/theme/Theme.kt\npackage com.fatec.bovino.ui.theme\n\nimport android.os.Build\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.darkColorScheme\nimport androidx.compose.material3.dynamicDarkColorScheme\nimport androidx.compose.material3.dynamicLightColorScheme\nimport androidx.compose.material3.lightColorScheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\n\nprivate val DarkColorScheme = darkColorScheme(\n    primary = Purple80,\n    secondary = PurpleGrey80,\n    tertiary = Pink80,\n    background = Color(0xFF1C1B1F),\n    surface = Color(0xFF1C1B1F),\n    onPrimary = Color.White,\n    onSecondary = Color.White,\n    onTertiary = Color.White,\n    onBackground = Color(0xFFE6E1E5),\n    onSurface = Color(0xFFE6E1E5),\n)\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40,\n    background = Color(0xFFFFFBFE),\n    surface = Color(0xFFFFFBFE),\n    onPrimary = Color.White,\n    onSecondary = Color.White,\n    onTertiary = Color.White,\n    onBackground = Color(0xFF1C1B1F),\n    onSurface = Color(0xFF1C1B1F),\n)\n\n@Composable\nfun BovinoTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    // Dynamic color is available on Android 12+\n    dynamicColor: Boolean = true,\n    content: @Composable () -&gt; Unit\n) {\n    val colorScheme = when {\n        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n\n        darkTheme -&gt; DarkColorScheme\n        else -&gt; LightColorScheme\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = Typography,\n        content = content\n    )\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o/","title":"Revis\u00e3o Conceitual: PDMII e LDDM","text":""},{"location":"PDMII/Revis%C3%A3o/#1-introducao-ao-jetpack-compose","title":"1. Introdu\u00e7\u00e3o ao Jetpack Compose","text":"<p>O Jetpack Compose \u00e9 um toolkit moderno para construir interfaces de usu\u00e1rio nativas no Android. Ele adota uma abordagem declarativa, o que significa que voc\u00ea descreve como sua UI deve ser em diferentes estados, e o Compose se encarrega de atualizar a UI quando o estado muda.</p> <p>Linguagem de Programa\u00e7\u00e3o: A linguagem mais utilizada e recomendada para desenvolver aplicativos Android com Jetpack Compose \u00e9 o Kotlin. O Kotlin oferece recursos que se alinham perfeitamente com a natureza declarativa do Compose, como fun\u00e7\u00f5es de extens\u00e3o, lambdas e delega\u00e7\u00e3o de propriedades.</p>"},{"location":"PDMII/Revis%C3%A3o/#2-gerenciamento-de-estado-no-jetpack-compose","title":"2. Gerenciamento de Estado no Jetpack Compose","text":"<p>O gerenciamento de estado \u00e9 um dos pilares do Jetpack Compose, garantindo que a interface do usu\u00e1rio seja reativa e se atualize automaticamente quando os dados subjacentes mudam.</p>"},{"location":"PDMII/Revis%C3%A3o/#o-que-e-estado","title":"O que \u00e9 \"Estado\"?","text":"<p>Em uma aplica\u00e7\u00e3o, \"estado\" refere-se a qualquer valor que pode mudar ao longo do tempo e que afeta a interface do usu\u00e1rio. Exemplos incluem o texto digitado em um campo, a visibilidade de um elemento, a cor de um componente ou uma lista de itens.</p>"},{"location":"PDMII/Revis%C3%A3o/#remember-e-mutablestateof","title":"remember e mutableStateOf","text":"<p>No Jetpack Compose, o principal mecanismo fundamental para gerenciar o estado de forma reativa \u00e9 a combina\u00e7\u00e3o de <code>remember</code> e <code>mutableStateOf</code>.</p> <p>mutableStateOf: Cria um objeto observ\u00e1vel que cont\u00e9m um valor. Quando o valor dentro de um MutableState muda, o Compose \u00e9 notificado e recomp\u00f5e (redesenha) os Composables que leem esse estado.</p> <pre><code>val count = mutableStateOf(0)\n</code></pre> <p>remember: \u00c9 uma fun\u00e7\u00e3o Composable que armazena um objeto na mem\u00f3ria durante a recomposi\u00e7\u00e3o. Sem <code>remember</code>, o estado seria redefinido para seu valor inicial a cada recomposi\u00e7\u00e3o. Ele \"lembra\" o valor entre as recomposi\u00e7\u00f5es da fun\u00e7\u00e3o Composable.</p> <pre><code>val count = remember { mutableStateOf(0) }\n</code></pre> <p>Isso garante que, mesmo que a fun\u00e7\u00e3o Composable seja chamada novamente, o valor de <code>count</code> persistir\u00e1.</p>"},{"location":"PDMII/Revis%C3%A3o/#uso-do-by-com-remember-delegacao-de-propriedades","title":"Uso do by com remember (Delega\u00e7\u00e3o de Propriedades)","text":"<p>O Kotlin oferece um recurso chamado delega\u00e7\u00e3o de propriedades que simplifica a sintaxe ao usar <code>mutableStateOf</code> com <code>remember</code>. O operador <code>by</code> permite que voc\u00ea acesse diretamente o valor do MutableState sem precisar usar <code>.value</code>.</p> <p>Compare:</p> <p>Sem <code>by</code>: <pre><code>val countState = remember { mutableStateOf(0) }\nText(text = \"Contagem: ${countState.value}\")\nButton(onClick = { countState.value++ }) {\n    Text(\"Incrementar\")\n}\n</code></pre></p> <p>Com <code>by</code>: <pre><code>var count by remember { mutableStateOf(0) } // 'var' \u00e9 necess\u00e1rio aqui\nText(text = \"Contagem: $count\")\nButton(onClick = { count++ }) {\n    Text(\"Incrementar\")\n}\n</code></pre></p> <p>A sintaxe <code>by</code> torna o c\u00f3digo mais conciso e leg\u00edvel, permitindo que voc\u00ea trate <code>count</code> como uma vari\u00e1vel comum, enquanto por baixo dos panos, ela ainda \u00e9 um MutableState.</p>"},{"location":"PDMII/Revis%C3%A3o/#state-hoisting-elevacao-de-estado","title":"State Hoisting (Eleva\u00e7\u00e3o de Estado)","text":"<p>State Hoisting \u00e9 um padr\u00e3o no Jetpack Compose onde o estado \u00e9 movido para cima na hierarquia de Composables, para um ancestral comum que pode gerenciar e observar esse estado. Isso torna os Composables mais reutiliz\u00e1veis, test\u00e1veis e menos acoplados ao estado.</p> <p>Benef\u00edcios:</p> <ul> <li>Unidirecionalidade do fluxo de dados: O estado flui para baixo (do pai para o filho) e os eventos fluem para cima (do filho para o pai).</li> <li>Reutiliza\u00e7\u00e3o: Composables filhos se tornam \"stateless\" (sem estado pr\u00f3prio), facilitando a reutiliza\u00e7\u00e3o em diferentes contextos.</li> <li>Testabilidade: Componentes sem estado s\u00e3o mais f\u00e1ceis de testar.</li> <li>Separa\u00e7\u00e3o de preocupa\u00e7\u00f5es: Onde o estado \u00e9 definido e modificado \u00e9 separado de onde ele \u00e9 usado na UI.</li> </ul> <p>Exemplo: Em vez de um <code>CattleCardComponent</code> gerenciar seu pr\u00f3prio estado de \"sa\u00fade\", o estado de sa\u00fade seria elevado para uma tela ou ViewModel que gerencia a lista de bovinos, e o <code>CattleCardComponent</code> receberia o estado como um par\u00e2metro.</p>"},{"location":"PDMII/Revis%C3%A3o/#tipos-de-gerenciamento-de-estado","title":"Tipos de Gerenciamento de Estado","text":"<p>O gerenciamento de estado pode ser categorizado de v\u00e1rias formas:</p> <ul> <li> <p>Estado Interno do Composable (remember / mutableStateOf): Para estados que s\u00e3o relevantes apenas para um Composable espec\u00edfico e n\u00e3o precisam ser compartilhados ou observados por outros. Este estado \u00e9 perdido em caso de recria\u00e7\u00e3o da Activity.</p> </li> <li> <p>Estado Interno Persistente do Composable (rememberSaveable / mutableStateOf): Para estados que s\u00e3o relevantes para um Composable espec\u00edfico e precisam sobreviver \u00e0 recria\u00e7\u00e3o da Activity (ex., rota\u00e7\u00e3o de tela).</p> </li> <li> <p>Estado Elevado (State Hoisting): Quando o estado \u00e9 movido para um Composable ancestral ou um ViewModel para ser compartilhado e gerenciado centralmente.</p> </li> <li> <p>Estado Compartilhado (Shared State): Quando m\u00faltiplos Composables precisam acessar e/ou modificar o mesmo peda\u00e7o de estado. Isso \u00e9 geralmente alcan\u00e7ado atrav\u00e9s de State Hoisting para um ViewModel ou um Composable pai.</p> </li> </ul>"},{"location":"PDMII/Revis%C3%A3o/#3-composables-de-layout-e-modifiers","title":"3. Composables de Layout e Modifiers","text":"<p>O Jetpack Compose oferece uma s\u00e9rie de Composables para organizar elementos na tela e Modifiers para personalizar sua apar\u00eancia e comportamento.</p>"},{"location":"PDMII/Revis%C3%A3o/#text","title":"Text","text":"<p>O Composable mais adequado para exibir dados textuais simples, como o nome de um animal ou um pre\u00e7o.</p> <pre><code>Text(text = \"Nome do Animal: Bovino 123\")\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o/#row","title":"Row","text":"<p>Usado para organizar elementos horizontalmente, um ao lado do outro.</p> <pre><code>Row {\n    Text(\"Brinco: 001\")\n    Text(\"Data Nasc.: 01/01/2023\")\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o/#column","title":"Column","text":"<p>Usado para organizar elementos verticalmente, um abaixo do outro. Ideal para listas de informa\u00e7\u00f5es ou para o <code>CattleCardComponent</code>.</p> <pre><code>Column {\n    Text(\"ID: 456\")\n    Text(\"Ra\u00e7a: Nelore\")\n    Text(\"Status: Saud\u00e1vel\")\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o/#box","title":"Box","text":"<p>Permite empilhar elementos um sobre o outro (como frames em uma caixa) ou usar um Composable como plano de fundo para outro. \u00c9 \u00fatil para criar efeitos de cont\u00eainer com fundos personalizados.</p> <pre><code>Box(\n    modifier = Modifier\n        .background(Color.Red)\n        .padding(8.dp)\n) {\n    Text(\"ATEN\u00c7\u00c3O!\", color = Color.White)\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o/#modifier","title":"Modifier","text":"<p>Uma classe essencial no Compose que permite encadear diversas propriedades visuais e de layout em um Composable. Ele n\u00e3o \u00e9 um Composable em si, mas um objeto que voc\u00ea passa para os Composables para modific\u00e1-los.</p> <pre><code>Text(\n    text = \"Meu Texto\",\n    modifier = Modifier\n        .padding(16.dp) // Espa\u00e7amento interno\n        .background(Color.Blue) // Cor de fundo\n        .fillMaxWidth() // Ocupa a largura m\u00e1xima\n)\n</code></pre> <p><code>Modifier</code> \u00e9 a classe principal que prov\u00ea a funcionalidade para definir atributos visuais como margens (<code>padding</code>), preenchimento (<code>padding</code>), cor de fundo (<code>background</code>), tamanho (<code>size</code>), etc.</p>"},{"location":"PDMII/Revis%C3%A3o/#4-temas-e-material-design","title":"4. Temas e Material Design","text":"<p>O Jetpack Compose, em conjunto com o Material Design, oferece ferramentas poderosas para garantir consist\u00eancia visual e ader\u00eancia \u00e0s diretrizes de design modernas.</p>"},{"location":"PDMII/Revis%C3%A3o/#materialtheme","title":"MaterialTheme","text":"<p>\u00c9 o recurso do Jetpack Compose amplamente utilizado que abrange um conjunto de componentes e diretrizes para construir interfaces coesas. Ele define a tipografia, cores e formas que ser\u00e3o usadas em toda a aplica\u00e7\u00e3o, garantindo uma apar\u00eancia unificada.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\n    MaterialTheme(\n        colors = MyColors, // Cores personalizadas\n        typography = MyTypography, // Tipografia personalizada\n        shapes = MyShapes, // Formas personalizadas\n        content = content\n    )\n}\n</code></pre>"},{"location":"PDMII/Revis%C3%A3o/#personalizacao-de-cores-ex-top-app-bar","title":"Personaliza\u00e7\u00e3o de Cores (Ex: Top App Bar)","text":"<p>Para mudar dinamicamente a cor de fundo de um componente como a Top App Bar, voc\u00ea geralmente usa a propriedade <code>containerColor</code> (ou <code>backgroundColor</code> em vers\u00f5es mais antigas ou dependendo do Composable espec\u00edfico).</p> <pre><code>TopAppBar(\n    title = { Text(\"Gerenciamento de Bovinos\") },\n    colors = TopAppBarDefaults.topAppBarColors(\n        containerColor = if (hasAlert) Color.Red else MaterialTheme.colorScheme.primary // Vermelho para alerta\n    )\n)\n</code></pre> <p>Dentro do <code>MaterialTheme</code>, voc\u00ea pode definir paletas de cores, tipografias e formas que ser\u00e3o automaticamente aplicadas aos componentes do Material Design.</p>"},{"location":"PDMII/Revis%C3%A3o/#5-escopos-no-compose","title":"5. Escopos no Compose","text":"<p>No Jetpack Compose, \"escopos\" referem-se aos receptores impl\u00edcitos de fun\u00e7\u00f5es lambda que s\u00e3o passadas para certos Composables. Eles permitem que voc\u00ea acesse propriedades ou fun\u00e7\u00f5es espec\u00edficas do contexto do Composable pai.</p> <p>Por exemplo:</p> <p>ColumnScope: Quando voc\u00ea coloca conte\u00fado dentro de um <code>Column</code>, a lambda que define esse conte\u00fado tem um receptor <code>ColumnScope</code>. Isso permite que voc\u00ea use modificadores espec\u00edficos de Column, como <code>align(Alignment.CenterHorizontally)</code>.</p> <pre><code>Column { // This lambda has ColumnScope\n    Text(\"Item 1\", modifier = Modifier.align(Alignment.CenterHorizontally))\n    Text(\"Item 2\")\n}\n</code></pre> <p>RowScope: Similarmente, para <code>Row</code>, a lambda tem um receptor <code>RowScope</code>, permitindo modificadores como <code>weight(1f)</code> para distribuir o espa\u00e7o horizontalmente.</p> <pre><code>Row { // This lambda has RowScope\n    Text(\"Item 1\", modifier = Modifier.weight(1f))\n    Text(\"Item 2\", modifier = Modifier.weight(1f))\n}\n</code></pre> <p>Esses escopos garantem que voc\u00ea s\u00f3 possa usar modificadores que fazem sentido no contexto do layout pai, melhorando a seguran\u00e7a e a clareza do c\u00f3digo.</p>"},{"location":"PDMII/Revis%C3%A3o/#6-estrutura-de-navegacao-no-jetpack-compose","title":"6. Estrutura de Navega\u00e7\u00e3o no Jetpack Compose","text":"<p>A navega\u00e7\u00e3o no Jetpack Compose \u00e9 gerenciada principalmente pela biblioteca Navigation-Compose, que faz parte do Android Jetpack. Ela utiliza um grafo de navega\u00e7\u00e3o para definir os destinos e as rotas entre eles.</p> <p>Os componentes chave para a navega\u00e7\u00e3o s\u00e3o:</p> <ul> <li> <p>NavController: \u00c9 o controlador central de navega\u00e7\u00e3o. Ele \u00e9 respons\u00e1vel por navegar entre os destinos, gerenciar a back stack e passar argumentos. Voc\u00ea o obt\u00e9m usando <code>rememberNavController()</code>.</p> </li> <li> <p>NavHost: Um Composable que hospeda o grafo de navega\u00e7\u00e3o. Ele \u00e9 respons\u00e1vel por exibir o Composable correto para o destino atual.</p> </li> <li> <p>composable: Uma fun\u00e7\u00e3o que define um destino no grafo de navega\u00e7\u00e3o, associando uma rota (string) a um Composable.</p> </li> </ul>"},{"location":"PDMII/Revis%C3%A3o/#estrutura-basica","title":"Estrutura B\u00e1sica:","text":"<pre><code>@Composable\nfun MyApp() {\n    val navController = rememberNavController() // 1. Obter o NavController\n\n    NavHost(\n        navController = navController, // 2. Passar o NavController para o NavHost\n        startDestination = \"list_screen\" // 3. Definir a tela inicial\n    ) {\n        // 4. Definir os destinos usando 'composable'\n        composable(\"list_screen\") {\n            // Conte\u00fado da tela de listagem\n            ListScreen(onNavigateToDetail = { navController.navigate(\"detail_screen/$it\") })\n        }\n        composable(\"detail_screen/{itemId}\") { backStackEntry -&gt;\n            // Conte\u00fado da tela de detalhes, acessando argumentos\n            val itemId = backStackEntry.arguments?.getString(\"itemId\")\n            DetailScreen(itemId = itemId)\n        }\n    }\n}\n\n@Composable\nfun ListScreen(onNavigateToDetail: (String) -&gt; Unit) {\n    Column {\n        Text(\"Tela de Listagem\")\n        Button(onClick = { onNavigateToDetail(\"bovino001\") }) {\n            Text(\"Ver Detalhes do Bovino 001\")\n        }\n    }\n}\n\n@Composable\nfun DetailScreen(itemId: String?) {\n    Column {\n        Text(\"Tela de Detalhes para: $itemId\")\n        // Exibir detalhes do bovino\n    }\n}\n</code></pre> <p>Rotas: S\u00e3o strings que identificam cada tela (\"list_screen\", \"detail_screen\").</p> <p>Argumentos: Podem ser passados entre telas, como \"{itemId}\" no exemplo.</p> <p>Navega\u00e7\u00e3o: Usa-se <code>navController.navigate(\"route_name\")</code> para ir para uma nova tela.</p> <p>Voltar: O NavController gerencia a pilha de navega\u00e7\u00e3o, permitindo que o usu\u00e1rio volte para a tela anterior com o bot\u00e3o \"Voltar\" do sistema.</p> <p>Este documento de revis\u00e3o serve como um guia abrangente para os conceitos essenciais do Jetpack Compose, preparando voc\u00ea para desenvolver aplica\u00e7\u00f5es Android modernas e reativas.</p>"},{"location":"PDMII/Gerenciamento%20de%20Estado/state/","title":"Explica\u00e7\u00e3o do C\u00f3digo CounterScreen em Jetpack Compose","text":"<p>Este c\u00f3digo demonstra tr\u00eas padr\u00f5es diferentes de gerenciamento de estado no Jetpack Compose, um framework moderno para constru\u00e7\u00e3o de UIs no Android.</p>"},{"location":"PDMII/Gerenciamento%20de%20Estado/state/#visao-geral","title":"Vis\u00e3o Geral","text":"<p>O c\u00f3digo cria uma tela simples com tr\u00eas bot\u00f5es que funcionam como contadores, cada um ilustrando uma abordagem diferente para lidar com estado:</p> <ol> <li>Estado b\u00e1sico com <code>remember</code></li> <li>Estado persistente com <code>rememberSaveable</code></li> <li>Eleva\u00e7\u00e3o de estado (State Hoisting)</li> </ol>"},{"location":"PDMII/Gerenciamento%20de%20Estado/state/#estrutura-principal","title":"Estrutura Principal","text":"<pre><code>@Composable\nfun CounterScreen() {\n    Column(\n        Modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Implementa\u00e7\u00f5es dos contadores aqui\n    }\n}\n</code></pre> <ul> <li>Column: Organiza os elementos verticalmente</li> <li>Modifier.fillMaxSize(): Ocupa toda a tela dispon\u00edvel</li> <li>padding(16.dp): Adiciona espa\u00e7amento interno</li> <li>Arrangement.Center e Alignment.CenterHorizontally: Centraliza os elementos</li> </ul>"},{"location":"PDMII/Gerenciamento%20de%20Estado/state/#1-estado-basico-com-remember","title":"1. Estado B\u00e1sico com <code>remember</code>","text":"<p><pre><code>val count = remember { mutableIntStateOf(0) }\nButton(onClick = { count.intValue++ }) {\n    Text(\"Count: ${count.intValue}\")\n}\n</code></pre> - <code>remember</code>: Mant\u00e9m o estado durante recomposi\u00e7\u00f5es, mas \u00e9 destru\u00eddo quando a tela \u00e9 removida - <code>mutableIntStateOf(0)</code>: Cria um estado mut\u00e1vel inicializado com 0 - O bot\u00e3o incrementa o valor e exibe o contador atual</p>"},{"location":"PDMII/Gerenciamento%20de%20Estado/state/#2-estado-persistente-com-remembersaveable","title":"2.  Estado Persistente com rememberSaveable","text":"<p>kotlin Copy val countSaveable = rememberSaveable { mutableIntStateOf(0) } Button(onClick = { countSaveable.intValue++ }) {     Text(\"Count: ${countSaveable.intValue}\") } rememberSaveable: Similar ao remember, mas sobrevive a mudan\u00e7as de configura\u00e7\u00e3o (como rota\u00e7\u00e3o de tela)</p> <p>Ideal para manter estado entre recrea\u00e7\u00f5es de atividade</p> <ol> <li>Eleva\u00e7\u00e3o de Estado (State Hoisting) kotlin Copy var countLifting by rememberSaveable { mutableIntStateOf(0) } Counter(countLifting, onIncrement = { countLifting++ }) kotlin Copy @Composable fun Counter(count: Int, onIncrement: () -&gt; Unit) {     Button(onClick = onIncrement) {         Text(\"Count: $count\")     } } State Hoisting: Padr\u00e3o onde o estado \u00e9 movido para o componente pai</li> </ol> <p>Counter \u00e9 um componente stateless (sem estado pr\u00f3prio)</p> <p>Recebe o valor atual e uma lambda para notificar incrementos</p> <p>Vantagens:</p> <p>Reutiliza\u00e7\u00e3o do componente</p> <p>Estado controlado pelo pai</p> <p>F\u00e1cil teste isolado</p> <p>Conceitos Importantes Estado em Compose: Dados que podem mudar e afetam a UI</p> <p>Recomposi\u00e7\u00e3o: Processo de redesenhar a UI quando o estado muda</p> <p>State Hoisting: Padr\u00e3o recomendado para componentes reutiliz\u00e1veis</p> <p>Quando Usar Cada Abordagem remember: Estado tempor\u00e1rio que n\u00e3o precisa persistir</p> <p>rememberSaveable: Estado que deve sobreviver a mudan\u00e7as de configura\u00e7\u00e3o</p> <p>State Hoisting: Para componentes reutiliz\u00e1veis ou quando o estado precisa ser compartilhado</p>"}]}